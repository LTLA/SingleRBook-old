<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 3 Using single-cell references | Assigning cell types with SingleR</title>
  <meta name="description" content="The SingleR book. Because sometimes, a vignette just isn’t enough." />
  <meta name="generator" content="bookdown 0.18 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 3 Using single-cell references | Assigning cell types with SingleR" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="The SingleR book. Because sometimes, a vignette just isn’t enough." />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 3 Using single-cell references | Assigning cell types with SingleR" />
  
  <meta name="twitter:description" content="The SingleR book. Because sometimes, a vignette just isn’t enough." />
  



<meta name="date" content="2020-04-27" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="using-the-built-in-references.html"/>
<link rel="next" href="annotation-diagnostics.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">The SingleR book</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a></li>
<li class="chapter" data-level="1" data-path="introduction.html"><a href="introduction.html"><i class="fa fa-check"></i><b>1</b> Introduction</a></li>
<li class="chapter" data-level="2" data-path="using-the-built-in-references.html"><a href="using-the-built-in-references.html"><i class="fa fa-check"></i><b>2</b> Using the built-in references</a><ul>
<li class="chapter" data-level="2.1" data-path="using-the-built-in-references.html"><a href="using-the-built-in-references.html#running-the-algorithm"><i class="fa fa-check"></i><b>2.1</b> Running the algorithm</a></li>
<li class="chapter" data-level="2.2" data-path="using-the-built-in-references.html"><a href="using-the-built-in-references.html#available-references"><i class="fa fa-check"></i><b>2.2</b> Available references</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="using-single-cell-references.html"><a href="using-single-cell-references.html"><i class="fa fa-check"></i><b>3</b> Using single-cell references</a><ul>
<li class="chapter" data-level="3.1" data-path="using-single-cell-references.html"><a href="using-single-cell-references.html#running-the-algorithm-1"><i class="fa fa-check"></i><b>3.1</b> Running the algorithm</a></li>
<li class="chapter" data-level="3.2" data-path="using-single-cell-references.html"><a href="using-single-cell-references.html#defining-custom-markers"><i class="fa fa-check"></i><b>3.2</b> Defining custom markers</a></li>
<li class="chapter" data-level="3.3" data-path="using-single-cell-references.html"><a href="using-single-cell-references.html#pseudo-bulk-aggregation"><i class="fa fa-check"></i><b>3.3</b> Pseudo-bulk aggregation</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="annotation-diagnostics.html"><a href="annotation-diagnostics.html"><i class="fa fa-check"></i><b>4</b> Annotation diagnostics</a><ul>
<li class="chapter" data-level="4.1" data-path="annotation-diagnostics.html"><a href="annotation-diagnostics.html#based-on-the-scores-within-cells"><i class="fa fa-check"></i><b>4.1</b> Based on the scores within cells</a></li>
<li class="chapter" data-level="4.2" data-path="annotation-diagnostics.html"><a href="annotation-diagnostics.html#based-on-the-deltas-across-cells"><i class="fa fa-check"></i><b>4.2</b> Based on the deltas across cells</a></li>
<li class="chapter" data-level="4.3" data-path="annotation-diagnostics.html"><a href="annotation-diagnostics.html#based-on-marker-gene-expression"><i class="fa fa-check"></i><b>4.3</b> Based on marker gene expression</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="using-multiple-references.html"><a href="using-multiple-references.html"><i class="fa fa-check"></i><b>5</b> Using multiple references</a></li>
<li class="chapter" data-level="6" data-path="harmonizing-labels.html"><a href="harmonizing-labels.html"><i class="fa fa-check"></i><b>6</b> Harmonizing labels</a></li>
<li class="chapter" data-level="7" data-path="advanced-options.html"><a href="advanced-options.html"><i class="fa fa-check"></i><b>7</b> Advanced options</a><ul>
<li class="chapter" data-level="7.1" data-path="advanced-options.html"><a href="advanced-options.html#improving-efficiency"><i class="fa fa-check"></i><b>7.1</b> Improving efficiency</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://bioconductor.org" target="blank">Published by Bioconductor</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Assigning cell types with SingleR</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="using-single-cell-references" class="section level1">
<h1><span class="header-section-number">Chapter 3</span> Using single-cell references</h1>
<div id="running-the-algorithm-1" class="section level2">
<h2><span class="header-section-number">3.1</span> Running the algorithm</h2>
<p>Here, we will use two human pancreas datasets from the <em><a href="https://bioconductor.org/packages/3.11/scRNAseq">scRNAseq</a></em> package. The aim is to use one pre-labelled dataset to annotate the other unlabelled dataset. First, we set up the <span class="citation">Muraro et al. (<a href="#ref-muraro2016singlecell">2016</a>)</span> dataset to be our reference.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scRNAseq)
sceM &lt;-<span class="st"> </span><span class="kw">MuraroPancreasData</span>()

<span class="co"># One should normally do cell-based quality control at this point, but for</span>
<span class="co"># brevity&#39;s sake, we will just remove the unlabelled libraries here.</span>
sceM &lt;-<span class="st"> </span>sceM[,<span class="op">!</span><span class="kw">is.na</span>(sceM<span class="op">$</span>label)]

<span class="kw">library</span>(scater)
sceM &lt;-<span class="st"> </span><span class="kw">logNormCounts</span>(sceM)</code></pre></div>
<p>We then set up our test dataset from <span class="citation">Grun et al. (<a href="#ref-grun2016denovo">2016</a>)</span>. To speed up this demonstration, we will subset to the first 100 cells.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sceG &lt;-<span class="st"> </span><span class="kw">GrunPancreasData</span>()
sceG &lt;-<span class="st"> </span>sceG[,<span class="kw">colSums</span>(<span class="kw">counts</span>(sceG)) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>] <span class="co"># Remove libraries with no counts.</span>
sceG &lt;-<span class="st"> </span><span class="kw">logNormCounts</span>(sceG) 
sceG &lt;-<span class="st"> </span>sceG[,<span class="dv">1</span><span class="op">:</span><span class="dv">100</span>]</code></pre></div>
<p>We then run <code>SingleR()</code> as described previously but with a marker detection mode that considers the variance of expression across cells. Here, we will use the Wilcoxon ranked sum test to identify the top markers for each pairwise comparison between labels. This is slower but more appropriate for single-cell data compared to the default marker detection algorithm (which may fail for low-coverage data where the median is frequently zero).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(SingleR)
pred.grun &lt;-<span class="st"> </span><span class="kw">SingleR</span>(<span class="dt">test=</span>sceG, <span class="dt">ref=</span>sceM, <span class="dt">labels=</span>sceM<span class="op">$</span>label, <span class="dt">de.method=</span><span class="st">&quot;wilcox&quot;</span>)
<span class="kw">table</span>(pred.grun<span class="op">$</span>labels)</code></pre></div>
<pre><code>## 
## acinar   beta  delta   duct 
##     53      4      2     41</code></pre>
</div>
<div id="defining-custom-markers" class="section level2">
<h2><span class="header-section-number">3.2</span> Defining custom markers</h2>
<p>Users can also construct their own marker lists with any DE testing machinery. For example, we can perform pairwise <span class="math inline">\(t\)</span>-tests using methods from <em><a href="https://bioconductor.org/packages/3.11/scran">scran</a></em> and obtain the top 10 marker genes from each pairwise comparison.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scran)
out &lt;-<span class="st"> </span><span class="kw">pairwiseTTests</span>(<span class="kw">logcounts</span>(sceM), sceM<span class="op">$</span>label, <span class="dt">direction=</span><span class="st">&quot;up&quot;</span>)
markers &lt;-<span class="st"> </span><span class="kw">getTopMarkers</span>(out<span class="op">$</span>statistics, out<span class="op">$</span>pairs, <span class="dt">n=</span><span class="dv">10</span>)</code></pre></div>
<p>We then supply these genes to <code>SingleR()</code> directly via the <code>genes=</code> argument. A more focused gene set also allows annotation to be performed more quickly compared to the default approach.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pred.grun2 &lt;-<span class="st"> </span><span class="kw">SingleR</span>(<span class="dt">test=</span>sceG, <span class="dt">ref=</span>sceM, <span class="dt">labels=</span>sceM<span class="op">$</span>label, <span class="dt">genes=</span>markers)
<span class="kw">table</span>(pred.grun2<span class="op">$</span>labels)</code></pre></div>
<pre><code>## 
##  acinar    beta   delta    duct      pp unclear 
##      59       4       1      34       1       1</code></pre>
<p>In some cases, markers may only be available for specific labels rather than for pairwise comparisons between labels. This is accommodated by supplying a named list of character vectors to <code>genes</code>. Note that this is likely to be less powerful than the list-of-lists approach as information about pairwise differences is discarded.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">label.markers &lt;-<span class="st"> </span><span class="kw">lapply</span>(markers, unlist, <span class="dt">recursive=</span><span class="ot">FALSE</span>)
pred.grun3 &lt;-<span class="st"> </span><span class="kw">SingleR</span>(<span class="dt">test=</span>sceG, <span class="dt">ref=</span>sceM, <span class="dt">labels=</span>sceM<span class="op">$</span>label, <span class="dt">genes=</span>label.markers)
<span class="kw">table</span>(pred.grun<span class="op">$</span>labels, pred.grun3<span class="op">$</span>labels)</code></pre></div>
<pre><code>##         
##          acinar beta delta duct pp
##   acinar     51    0     0    2  0
##   beta        0    4     0    0  0
##   delta       0    0     1    0  1
##   duct        2    0     0   39  0</code></pre>
</div>
<div id="pseudo-bulk-aggregation" class="section level2">
<h2><span class="header-section-number">3.3</span> Pseudo-bulk aggregation</h2>
<p>Single-cell reference datasets provide a like-for-like comparison to our test datasets, yielding a more accurate classification of the cells in the latter (hopefully). However, there are frequently many more samples in single-cell references compared to bulk references, increasing the computational work involved in classification. We avoid this by aggregating cells into one “pseudo-bulk” sample per label (e.g., by averaging across log-expression values) and using those as the reference, which allows us to achieve the same efficiency as the use of bulk references.</p>
<p>The obvious cost of this approach is that we discard potentially useful information about the distribution of cells within each label. Cells that belong to a heterogeneous population may not be correctly assigned if they are far from the population center. We attempt to preserve some of this information by using <span class="math inline">\(k\)</span>-means clustering within each cell to create pseudo-bulk samples that are representative of a particular region of the expression space (i.e., vector quantization). We create <span class="math inline">\(\sqrt{N}\)</span> clusters given a label with <span class="math inline">\(N\)</span> cells, which provides a reasonable compromise between reducing computational work and preserving the label’s internal distribution.</p>
<p>This aggregation approach is implemented in the <code>aggregateReferences</code> function, which is shown in action below for the <span class="citation">Muraro et al. (<a href="#ref-muraro2016singlecell">2016</a>)</span> dataset. The function returns a <code>SummarizedExperiment</code> object containing the pseudo-bulk expression profiles and the corresponding labels.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">100</span>) <span class="co"># for the k-means step.</span>
aggr &lt;-<span class="st"> </span><span class="kw">aggregateReference</span>(sceM, <span class="dt">labels=</span>sceM<span class="op">$</span>label)
aggr</code></pre></div>
<pre><code>## class: SummarizedExperiment 
## dim: 19059 116 
## metadata(0):
## assays(1): logcounts
## rownames(19059): A1BG-AS1__chr19 A1BG__chr19 ... ZZEF1__chr17
##   ZZZ3__chr1
## rowData names(0):
## colnames(116): alpha.1 alpha.2 ... mesenchymal.8 epsilon.1
## colData names(1): label</code></pre>
<p>The resulting <code>SummarizedExperiment</code> can then be used as a reference in <code>SingleR()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pred.aggr &lt;-<span class="st"> </span><span class="kw">SingleR</span>(sceG, aggr, <span class="dt">labels=</span>aggr<span class="op">$</span>label)
<span class="kw">table</span>(pred.aggr<span class="op">$</span>labels)</code></pre></div>
<pre><code>## 
## acinar   beta  delta   duct 
##     53      4      1     42</code></pre>

</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-grun2016denovo">
<p>Grun, D., M. J. Muraro, J. C. Boisset, K. Wiebrands, A. Lyubimova, G. Dharmadhikari, M. van den Born, et al. 2016. “De Novo Prediction of Stem Cell Identity using Single-Cell Transcriptome Data.” <em>Cell Stem Cell</em> 19 (2): 266–77.</p>
</div>
<div id="ref-muraro2016singlecell">
<p>Muraro, M. J., G. Dharmadhikari, D. Grun, N. Groen, T. Dielen, E. Jansen, L. van Gurp, et al. 2016. “A Single-Cell Transcriptome Atlas of the Human Pancreas.” <em>Cell Syst</em> 3 (4): 385–94.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="using-the-built-in-references.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="annotation-diagnostics.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": false,
"twitter": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
},
"bookdown::epub_book": "default",
"cover": "images/cover.png"
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
