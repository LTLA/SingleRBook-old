[
["index.html", "Assigning cell types with SingleR Preface", " Assigning cell types with SingleR 2020-05-20 Preface Imagine a world without a reference genome. Whenever you receive new sequencing data - and we’ll just talk about transcriptomic data for now - you’ll have to run it through an assembler to characterize the genes that are being expressed. If you’re lucky enough to get a decent assembly that isn’t confused by contamination or homologous sequences, it falls on you to pick through the sequence to figure out what what the gene actually is. (BH3 domain? Probably pro-apoptotic. Homeobox domain? Something to do with development.) And if you’re at a conference and you hear the name of a gene you’re working on, how can you be sure that everyone’s talking about the same thing? Now, this particular hellscape only exists in nightmares and history books, but it’s easy to see the parallels with single-cell data analyses; simply replace reads with cells, assemblies with clusters, and genes with cell types. In the single-cell analysis field, a typical practitioner will hope that their clusters are reasonable proxies for the biological states of interest (a strong assumption indeed!) and that their manual annotation of the clusters is accurate (which is itself dependent on domain expertise, coffee consumption and grant application deadlines). The current process of clustering, looking at a handful of markers and making a guesstimate of the cell type is best described as “artisanal” - which is not inherently bad, but one would hope that a mature technology would not require so much manual intervention for its routine use. A useful life philosophy is that hard work is a disease for which automation is the cure, and this case is no exception. Automated cell type annotation methods match cells in a new dataset against curated reference profiles of known cell types, assigning each cell to the type that its expression profile is most similar to. This allows users to skip the mundane annotation of their data and jump directly to the interesting questions - does my cell type change in abundance or expression across treatments? Is there interesting substructure within an existing population? In this respect, automated annotation methods are the single-cell field’s equivalent to genome aligners; the latter are an integral part of almost all sequencing analysis pipelines, regarded in the same light as electricity, internet and running water. This book covers the use of SingleR, one implementation of an automated annotation method. If you want a survey of different annotation methods - this book is not for you. If you want to create hand-crafted cluster definitions - this book is not for you. (Read the other one instead.) If you want to use the pre-Bioconductor version of the package - this book is not for you. But if you’re tired of manually annotating your single-cell data and you want to do something better with your life, then read on, because SingleR is the enemy of pointless hard work. "],
["introduction.html", "Chapter 1 Introduction 1.1 Motivation 1.2 Method description 1.3 Quick start 1.4 Where to get help Session information", " Chapter 1 Introduction .aaron-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .aaron-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 1.1 Motivation The Bioconductor package SingleR implements an automatic annotation method for single-cell RNA sequencing (scRNA-seq) data (Aran et al. 2019). Given a reference dataset of samples (single-cell or bulk) with known labels, it assigns those labels to new cells from a test dataset based on similarities in their expression profiles. This provides a convenient way of transferring biological knowledge across datasets. allowing users to leverage the domain expertise implicit in the creation of each reference. The most common application of SingleR involves predicting cell type (or “state”, or “kind”) in a new dataset, a process that is facilitated by the availability of built-in references and compatibility with user-supplied datasets. In this manner, the burden of manually interpreting clusters and defining marker genes only has to be done once, for the reference dataset, and this knowledge can be propagated to new datasets in an automated manner. 1.2 Method description SingleR can be considered a robust variant of nearest-neighbors classification, with some tweaks to improve resolution for closely related labels. For each test cell: We compute the Spearman correlation between its expression profile and that of each reference sample. The use of Spearman’s correlation provides a measure of robustness to batch effects across datasets. The calculation only uses the union of marker genes identified by pairwise comparisons between labels in the reference data, so as to improve resolution of separation between labels. We define the per-label score as a fixed quantile (by default, 0.8) of the correlations across all samples with that label. This accounts for differences in the number of reference samples for each label, which interferes with simpler flavors of nearest neighbor classification; it also avoids penalizing classifications to heterogeneous labels by only requiring a good match to a minority of samples. We repeat the score calculation for all labels in the reference dataset. The label with the highest score is used as SingleR’s prediction for this cell. We optionally perform a fine-tuning step to improve resolution between closely related labels. The reference dataset is subsetted to only include labels with scores close to the maximum, scores are recomputed using only marker genes for the subset of labels (thus focusing on the most relevant features), and this is iterated until one label remains. 1.3 Quick start We will demonstrate the use of SingleR() on a classic 10X Genomics dataset (Zheng et al. 2017) with the built-in Human Primary Cell Atlas dataset (Mabbott et al. 2013) as the reference. # Loading test data. library(TENxPBMCData) new.data &lt;- TENxPBMCData(&quot;pbmc4k&quot;) # Loading reference data with Ensembl annotations. library(SingleR) ref.data &lt;- HumanPrimaryCellAtlasData(ensembl=TRUE) # Performing predictions. predictions &lt;- SingleR(test=new.data, assay.type.test=1, ref=ref.data, labels=ref.data$label.main) table(predictions$labels) ## ## B_cell CMP DC GMP ## 606 8 1 2 ## Monocyte NK_cell Platelets Pre-B_cell_CD34- ## 1164 217 3 46 ## T_cells ## 2293 And that’s it, really. 1.4 Where to get help Questions on the general use of SingleR should be posted to the Bioconductor support site. Please send requests for general assistance and advice to the support site rather than to the individual authors. Bug reports or feature requests should be made to the GitHub repository; well-considered suggestions for improvements are always welcome. Session information View session info R version 4.0.0 Patched (2020-05-01 r78341) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 18.04.4 LTS Matrix products: default BLAS: /home/luna/Software/R/R-4-0-branch-dev/lib/libRblas.so LAPACK: /home/luna/Software/R/R-4-0-branch-dev/lib/libRlapack.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 parallel stats graphics grDevices utils datasets [8] methods base other attached packages: [1] ensembldb_2.13.1 AnnotationFilter_1.13.0 [3] GenomicFeatures_1.41.0 AnnotationDbi_1.51.0 [5] SingleR_1.3.4 TENxPBMCData_1.7.0 [7] HDF5Array_1.17.0 rhdf5_2.33.0 [9] SingleCellExperiment_1.11.1 SummarizedExperiment_1.19.4 [11] DelayedArray_0.15.1 matrixStats_0.56.0 [13] Biobase_2.49.0 GenomicRanges_1.41.1 [15] GenomeInfoDb_1.25.0 IRanges_2.23.4 [17] S4Vectors_0.27.6 BiocGenerics_0.35.2 [19] BiocStyle_2.17.0 rebook_0.99.0 loaded via a namespace (and not attached): [1] ProtGenerics_1.21.0 bitops_1.0-6 [3] bit64_0.9-7 progress_1.2.2 [5] httr_1.4.1 tools_4.0.0 [7] R6_2.4.1 irlba_2.3.3 [9] lazyeval_0.2.2 DBI_1.1.0 [11] prettyunits_1.1.1 tidyselect_1.1.0 [13] processx_3.4.2 bit_1.1-15.2 [15] curl_4.3 compiler_4.0.0 [17] graph_1.67.0 BiocNeighbors_1.7.0 [19] rtracklayer_1.49.1 bookdown_0.19 [21] askpass_1.1 callr_3.4.3 [23] rappdirs_0.3.1 Rsamtools_2.5.0 [25] stringr_1.4.0 digest_0.6.25 [27] rmarkdown_2.1 XVector_0.29.0 [29] pkgconfig_2.0.3 htmltools_0.4.0 [31] dbplyr_1.4.3 fastmap_1.0.1 [33] rlang_0.4.6 RSQLite_2.2.0 [35] shiny_1.4.0.2 DelayedMatrixStats_1.11.0 [37] BiocParallel_1.23.0 dplyr_0.8.5 [39] RCurl_1.98-1.2 magrittr_1.5 [41] BiocSingular_1.5.0 GenomeInfoDbData_1.2.3 [43] Matrix_1.2-18 Rcpp_1.0.4.6 [45] Rhdf5lib_1.11.0 lifecycle_0.2.0 [47] stringi_1.4.6 yaml_2.2.1 [49] zlibbioc_1.35.0 BiocFileCache_1.13.0 [51] AnnotationHub_2.21.0 grid_4.0.0 [53] blob_1.2.1 promises_1.1.0 [55] ExperimentHub_1.15.0 crayon_1.3.4 [57] lattice_0.20-41 Biostrings_2.57.0 [59] hms_0.5.3 CodeDepends_0.6.5 [61] knitr_1.28 ps_1.3.3 [63] pillar_1.4.4 codetools_0.2-16 [65] biomaRt_2.45.0 XML_3.99-0.3 [67] glue_1.4.1 BiocVersion_3.12.0 [69] evaluate_0.14 BiocManager_1.30.10 [71] vctrs_0.3.0 httpuv_1.5.2 [73] openssl_1.4.1 purrr_0.3.4 [75] assertthat_0.2.1 xfun_0.13 [77] rsvd_1.0.3 mime_0.9 [79] xtable_1.8-4 later_1.0.0 [81] tibble_3.0.1 GenomicAlignments_1.25.0 [83] memoise_1.1.0 ellipsis_0.3.1 [85] interactiveDisplayBase_1.27.0 Bibliography "],
["using-the-built-in-references.html", "Chapter 2 Using the built-in references 2.1 Overview 2.2 Annotation with default marker detection 2.3 Interaction with quality control 2.4 Choices of assay data Session information", " Chapter 2 Using the built-in references .aaron-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .aaron-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 2.1 Overview SingleR detects markers in a pairwise manner between labels in the reference dataset. Specifically, for each label of interest, it performs pairwise comparisons to every other label in the reference and identifies the genes that are upregulated in the label of interest for each comparison. The initial score calculation is then performed on the union of marker genes across all comparisons for all label. This approach ensures that the selected subset of features will contain genes that distinguish each label from any other label. (In contrast, other approaches that treat the “other” labels as a single group do not offer this guarantee; see here for a discussion.) It also allows the fine-tuning step to aggressively improve resolution by only using marker genes from comparisons involving labels that both have scores close to the maximum. The original (“classic”) marker detection algorithm used in Aran et al. (2019) identified marker genes based on their log-fold changes in each pairwise comparison. Specifically, it used the genes with the largest positive differences in the per-label median log-expression values between labels. The number of genes taken from each pairwise comparison was defined as \\(500 (\\frac{2}{3})^{\\log_{2}(n)}\\), where \\(n\\) is the number of unique labels in the reference; this aimed to reduce the number of genes (and thus the computational time) as the number of labels and pairwise comparisons increased. It is primarily intended for reference datasets that have little or no replication, a description that covers most of the built-in references and precludes more complicated marker detection procedures (Chapter 3). 2.2 Annotation with default marker detection For demonstration purposes, we will use the Grun et al. (2016) haematopoietic stem cell (HSC) dataset from the scRNAseq package. The GrunHSCData() function conveniently returns a SingleCellExperiment object containing the count matrix for this dataset. library(scRNAseq) sce &lt;- GrunHSCData(ensembl=TRUE) sce ## class: SingleCellExperiment ## dim: 21817 1915 ## metadata(0): ## assays(1): counts ## rownames(21817): ENSMUSG00000109644 ENSMUSG00000007777 ... ## ENSMUSG00000055670 ENSMUSG00000039068 ## rowData names(3): symbol chr originalName ## colnames(1915): JC4_349_HSC_FE_S13_ JC4_350_HSC_FE_S13_ ... ## JC48P6_1203_HSC_FE_S8_ JC48P6_1204_HSC_FE_S8_ ## colData names(2): sample protocol ## reducedDimNames(0): ## altExpNames(0): Our plan is to annotate each cell with the built-in ImmGen reference dataset (Heng et al. 2008). Calling the ImmGenData() function returns a SummarizedExperiment object containing a matrix of log-expression values with sample-level labels. We set ensembl=TRUE to match the reference’s gene annotation with that in the sce object (the default is to use the gene symbol). library(SingleR) immgen &lt;- ImmGenData(ensembl=TRUE) immgen ## class: SummarizedExperiment ## dim: 21352 830 ## metadata(0): ## assays(1): logcounts ## rownames(21352): ENSMUSG00000079681 ENSMUSG00000066372 ... ## ENSMUSG00000034640 ENSMUSG00000036940 ## rowData names(0): ## colnames(830): ## GSM1136119_EA07068_260297_MOGENE-1_0-ST-V1_MF.11C-11B+.LU_1.CEL ## GSM1136120_EA07068_260298_MOGENE-1_0-ST-V1_MF.11C-11B+.LU_2.CEL ... ## GSM920654_EA07068_201214_MOGENE-1_0-ST-V1_TGD.VG4+24ALO.E17.TH_1.CEL ## GSM920655_EA07068_201215_MOGENE-1_0-ST-V1_TGD.VG4+24ALO.E17.TH_2.CEL ## colData names(3): label.main label.fine label.ont Technically speaking, each built-in dataset actually has three sets of labels that primarily differ in their resolution. For the purposes of this demonstration, we will use the “fine” labels in the label.fine metadata field. head(immgen$label.fine) ## [1] &quot;Macrophages (MF.11C-11B+)&quot; &quot;Macrophages (MF.11C-11B+)&quot; ## [3] &quot;Macrophages (MF.11C-11B+)&quot; &quot;Macrophages (MF.ALV)&quot; ## [5] &quot;Macrophages (MF.ALV)&quot; &quot;Macrophages (MF.ALV)&quot; Annotation is then a simple matter of calling SingleR() on our test (Grun) dataset and the reference (ImmGen) dataset, leaving the default of de.method=&quot;classic&quot; to use the original marker detection scheme. This applies the algorithm described in Section 1.2, returning a DataFrame where each row contains prediction results for a single cell in the sce object. Labels are shown before fine-tuning (first.labels), after fine-tuning (labels) and after pruning (pruned.labels), along with the associated scores for each label. # See &#39;Choices of assay data&#39; for &#39;assay.type.test=&#39; explanation. pred &lt;- SingleR(test = sce, ref = immgen, labels = immgen$label.fine, assay.type.test=1) pred ## DataFrame with 1915 rows and 5 columns ## scores ## &lt;matrix&gt; ## JC4_349_HSC_FE_S13_ 0.02170371:0.023365296: 0.02462244:... ## JC4_350_HSC_FE_S13_ 0.03127428:0.031426006: 0.03286075:... ## JC4_351_HSC_FE_S13_ 0.02485081:0.024722089: 0.02174789:... ## JC4_352_HSC_FE_S13_ 0.03612959:0.036907421: 0.03950824:... ## JC4_353_HSC_FE_S13_ 0.00246304:0.000508024:-0.00191648:... ## ... ... ## JC48P6_1200_HSC_FE_S8_ 0.192889:0.192199:0.191950:... ## JC48P6_1201_HSC_FE_S8_ 0.164670:0.161995:0.162909:... ## JC48P6_1202_HSC_FE_S8_ 0.162044:0.160878:0.158804:... ## JC48P6_1203_HSC_FE_S8_ 0.175933:0.178043:0.180334:... ## JC48P6_1204_HSC_FE_S8_ 0.204651:0.205074:0.203180:... ## first.labels tuning.scores ## &lt;character&gt; &lt;DataFrame&gt; ## JC4_349_HSC_FE_S13_ T cells (T.8EFF.OT1.48HR.LISOVA) 0.0465958:0.0458002 ## JC4_350_HSC_FE_S13_ Stem cells (SC.CMP.DR) 0.0457856:0.0438811 ## JC4_351_HSC_FE_S13_ Stem cells (SC.MEP) 0.0328072:0.0321104 ## JC4_352_HSC_FE_S13_ Stem cells (SC.MEP) 0.0511217:0.0509664 ## JC4_353_HSC_FE_S13_ Macrophages (MF.103-11B+.SALM3) 0.0183372:0.0168012 ## ... ... ... ## JC48P6_1200_HSC_FE_S8_ Stem cells (SC.LT34F) 0.236700:0.1178367 ## JC48P6_1201_HSC_FE_S8_ Stem cells (MLP) 0.341081:0.2547433 ## JC48P6_1202_HSC_FE_S8_ Stem cells (SC.LT34F) 0.160514:0.0955061 ## JC48P6_1203_HSC_FE_S8_ Stem cells (SC.LT34F) 0.500000:0.5000000 ## JC48P6_1204_HSC_FE_S8_ Stem cells (SC.LT34F) 0.161313:0.1437619 ## labels ## &lt;character&gt; ## JC4_349_HSC_FE_S13_ T cells (T.8EFF.OT1.48HR.LISOVA) ## JC4_350_HSC_FE_S13_ Stem cells (SC.CMP.DR) ## JC4_351_HSC_FE_S13_ Stem cells (SC.MEP) ## JC4_352_HSC_FE_S13_ Stem cells (SC.MEP) ## JC4_353_HSC_FE_S13_ Macrophages (MF.103-11B+.SALM3) ## ... ... ## JC48P6_1200_HSC_FE_S8_ Stem cells (SC.LT34F) ## JC48P6_1201_HSC_FE_S8_ Stem cells (SC.ST34F) ## JC48P6_1202_HSC_FE_S8_ Stem cells (SC.LT34F) ## JC48P6_1203_HSC_FE_S8_ Stem cells (SC.STSL) ## JC48P6_1204_HSC_FE_S8_ Stem cells (SC.STSL) ## pruned.labels ## &lt;character&gt; ## JC4_349_HSC_FE_S13_ T cells (T.8EFF.OT1.48HR.LISOVA) ## JC4_350_HSC_FE_S13_ Stem cells (SC.CMP.DR) ## JC4_351_HSC_FE_S13_ Stem cells (SC.MEP) ## JC4_352_HSC_FE_S13_ Stem cells (SC.MEP) ## JC4_353_HSC_FE_S13_ Macrophages (MF.103-11B+.SALM3) ## ... ... ## JC48P6_1200_HSC_FE_S8_ Stem cells (SC.LT34F) ## JC48P6_1201_HSC_FE_S8_ Stem cells (SC.ST34F) ## JC48P6_1202_HSC_FE_S8_ Stem cells (SC.LT34F) ## JC48P6_1203_HSC_FE_S8_ Stem cells (SC.STSL) ## JC48P6_1204_HSC_FE_S8_ Stem cells (SC.STSL) 2.3 Interaction with quality control Upon summarizing the distribution of assigned labels, we see that many of them are related to stem cells, though there are quite a large number of more differentiated labels mixed in. This is probably because - despite what its name might suggest - the dataset obtained by GrunHSCData() actually contains more than HSCs. head(sort(table(pred$labels), decreasing=TRUE)) ## ## Stem cells (SC.MEP) Neutrophils (GN.ARTH) Macrophages (MF) ## 362 314 165 ## Stem cells (SC.STSL) B cells (proB.FrA) Stem cells (SC.LT34F) ## 142 121 103 If we restrict our analysis to the sorted HSCs (obviously) and remove one low-quality batch (see the analysis here for the rationale) we can see that the distribution of cell type labels is more similar to what we might expect. Low-quality cells - typically those with low library sizes and low numbers of detected genes - lack information for accurate label assignment and often need to be removed to enable interpretation of the results. actual.hsc &lt;- pred$labels[sce$protocol==&quot;sorted hematopoietic stem cells&quot; &amp; sce$sample!=&quot;JC4&quot;] head(sort(table(actual.hsc), decreasing=TRUE)) ## actual.hsc ## Stem cells (SC.STSL) Stem cells (SC.LT34F) ## 109 98 ## Stem cells (SC.ST34F) Stem cells (SC.CD150-CD48-) ## 37 15 ## Stem cells (LTHSC) Stem cells (MLP) ## 12 8 Filtering on the results in the above manner is possible because SingleR() operates independently on each cell. The annotation is orthogonal to any decisions about the relative quality of the cells in the test dataset; the same results will be obtained regardless of whether the annotation is performed before or after quality control. This is logisitically convenient as it means that the annotation does not have to be repeated if the quality control scheme (or any other downstream step, like clustering) changes throughout the lifetime of the analysis. 2.4 Choices of assay data For the reference dataset, the assay matrix must contain log-transformed normalized expression values. This is because the default marker detection scheme computes log-fold changes by subtracting the medians, which makes little sense unless the input expression values are already log-transformed. For alternative schemes, this requirement may be relaxed (e.g., Wilcoxon rank sum tests do not require transformation); similarly, if pre-defined markers are supplied, no transformaton or normalization is necessary (see comments below for the test data). For the test data, the assay data need not be log-transformed or even (scale) normalized. This is because SingleR() computes Spearman correlations within each cell, which is unaffected by monotonic transformations like cell-specific scaling or log-transformation. It is perfectly satisfactory to provide the raw counts for the test dataset to SingleR(), which is the reason for setting assay.type.test=1 in our previous SingleR() call for the Grun dataset. The exception to this rule occurs when comparing data from full-length technologies to the built-in references. The built-in references are constructed to be comparable to unique molecular identifier (UMI) protocols, where the expression values are less sensitive to differences in gene length. Thus, when comparing Smart-seq2 test datasets to the built-in references, better performance can often be achieved by processing the test counts to transcripts-per-million values. We demonstrate below using another HSC dataset that was generated using the Smart-seq2 protocol (???). Again, we see that most of the predicted labels are related to stem cells, which is comforting. sce.nest &lt;- NestorowaHSCData() # Getting the exonic gene lengths. library(AnnotationHub) mm.db &lt;- AnnotationHub()[[&quot;AH73905&quot;]] mm.exons &lt;- exonsBy(mm.db, by=&quot;gene&quot;) mm.exons &lt;- reduce(mm.exons) mm.len &lt;- sum(width(mm.exons)) # Computing the TPMs with a simple scaling by gene length. library(scater) keep &lt;- intersect(names(mm.len), rownames(sce.nest)) tpm.nest &lt;- calculateTPM(sce.nest[keep,], lengths=mm.len[keep]) # Performing the assignment. pred &lt;- SingleR(test = tpm.nest, ref = immgen, labels = immgen$label.fine) head(sort(table(pred$labels), decreasing=TRUE), 10) ## ## Stem cells (SC.MEP) Stem cells (SC.ST34F) ## 409 357 ## Stem cells (SC.MPP34F) Stem cells (SC.CMP.DR) ## 329 298 ## Stem cells (MLP) Stem cells (GMP) ## 167 102 ## Stem cells (SC.STSL) Stem cells (SC.MDP) ## 71 66 ## Stem cells (SC.CD150-CD48-) Stem cells (SC.LT34F) ## 55 37 Session information View session info R version 4.0.0 Patched (2020-05-01 r78341) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 18.04.4 LTS Matrix products: default BLAS: /home/luna/Software/R/R-4-0-branch-dev/lib/libRblas.so LAPACK: /home/luna/Software/R/R-4-0-branch-dev/lib/libRlapack.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] parallel stats4 stats graphics grDevices utils datasets [8] methods base other attached packages: [1] scater_1.17.0 ggplot2_3.3.0 [3] AnnotationHub_2.21.0 BiocFileCache_1.13.0 [5] dbplyr_1.4.3 SingleR_1.3.2 [7] ensembldb_2.13.1 AnnotationFilter_1.13.0 [9] GenomicFeatures_1.41.0 AnnotationDbi_1.51.0 [11] scRNAseq_2.3.0 SingleCellExperiment_1.11.1 [13] SummarizedExperiment_1.19.4 DelayedArray_0.15.1 [15] matrixStats_0.56.0 Biobase_2.49.0 [17] GenomicRanges_1.41.1 GenomeInfoDb_1.25.0 [19] IRanges_2.23.4 S4Vectors_0.27.6 [21] BiocGenerics_0.35.2 BiocStyle_2.17.0 [23] rebook_0.99.0 loaded via a namespace (and not attached): [1] ProtGenerics_1.21.0 bitops_1.0-6 [3] bit64_0.9-7 progress_1.2.2 [5] httr_1.4.1 tools_4.0.0 [7] irlba_2.3.3 R6_2.4.1 [9] vipor_0.4.5 colorspace_1.4-1 [11] DBI_1.1.0 lazyeval_0.2.2 [13] withr_2.2.0 gridExtra_2.3 [15] tidyselect_1.1.0 prettyunits_1.1.1 [17] processx_3.4.2 bit_1.1-15.2 [19] curl_4.3 compiler_4.0.0 [21] graph_1.67.0 BiocNeighbors_1.7.0 [23] rtracklayer_1.49.1 bookdown_0.19 [25] scales_1.1.1 callr_3.4.3 [27] askpass_1.1 rappdirs_0.3.1 [29] stringr_1.4.0 digest_0.6.25 [31] Rsamtools_2.5.0 rmarkdown_2.1 [33] XVector_0.29.0 pkgconfig_2.0.3 [35] htmltools_0.4.0 fastmap_1.0.1 [37] rlang_0.4.6 RSQLite_2.2.0 [39] DelayedMatrixStats_1.11.0 shiny_1.4.0.2 [41] BiocParallel_1.23.0 dplyr_0.8.5 [43] BiocSingular_1.5.0 RCurl_1.98-1.2 [45] magrittr_1.5 GenomeInfoDbData_1.2.3 [47] Matrix_1.2-18 ggbeeswarm_0.6.0 [49] munsell_0.5.0 Rcpp_1.0.4.6 [51] viridis_0.5.1 lifecycle_0.2.0 [53] stringi_1.4.6 yaml_2.2.1 [55] zlibbioc_1.35.0 grid_4.0.0 [57] blob_1.2.1 promises_1.1.0 [59] ExperimentHub_1.15.0 crayon_1.3.4 [61] lattice_0.20-41 Biostrings_2.57.0 [63] hms_0.5.3 CodeDepends_0.6.5 [65] knitr_1.28 ps_1.3.3 [67] pillar_1.4.4 codetools_0.2-16 [69] biomaRt_2.45.0 XML_3.99-0.3 [71] glue_1.4.1 BiocVersion_3.12.0 [73] evaluate_0.14 BiocManager_1.30.10 [75] vctrs_0.3.0 httpuv_1.5.2 [77] gtable_0.3.0 openssl_1.4.1 [79] purrr_0.3.4 assertthat_0.2.1 [81] xfun_0.13 rsvd_1.0.3 [83] mime_0.9 xtable_1.8-4 [85] later_1.0.0 viridisLite_0.3.0 [87] tibble_3.0.1 beeswarm_0.2.3 [89] GenomicAlignments_1.25.0 memoise_1.1.0 [91] ellipsis_0.3.1 interactiveDisplayBase_1.27.0 Bibliography "],
["using-single-cell-references.html", "Chapter 3 Using single-cell references 3.1 Overview 3.2 Annotation with test-based marker detection 3.3 Defining custom markers 3.4 Pseudo-bulk aggregation Session information", " Chapter 3 Using single-cell references .aaron-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .aaron-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 3.1 Overview Another application of SingleR involves using one single-cell dataset as a reference to annotate others. This is almost identical to the use of the built-in bulk references described in Chapter 2, with the main difference involving the marker detection strategy that is applied to the reference labels. In particular, we identify top-ranked markers based on pairwise Wilcoxon rank sum tests or \\(t\\)-tests between labels; this allows us to account for the variability across cells to choose genes that are robustly upregulated in each label. Despite the name of this chapter, the functionality described here is not limited to single-cell references. The determining factor is whether a dataset contains enough samples for each label to permit the use of statistical tests for marker detection. This scenario is most common for single-cell references but the same approach can be applied to bulk references with many replicate samples. 3.2 Annotation with test-based marker detection Here, we will use two human pancreas scRNA-seq datasets from the scRNAseq package. The aim is to use one pre-labelled dataset to annotate the other unlabelled dataset. First, we set up the Muraro et al. (2016) dataset to be our reference, computing log-normalized expression values as discussed in Section 2.4. library(scRNAseq) sceM &lt;- MuraroPancreasData() # Removing unlabelled cells or cells without a clear label. sceM &lt;- sceM[,!is.na(sceM$label) &amp; sceM$label!=&quot;unclear&quot;] library(scater) sceM &lt;- logNormCounts(sceM) sceM ## class: SingleCellExperiment ## dim: 19059 2122 ## metadata(0): ## assays(2): counts logcounts ## rownames(19059): A1BG-AS1__chr19 A1BG__chr19 ... ZZEF1__chr17 ## ZZZ3__chr1 ## rowData names(2): symbol chr ## colnames(2122): D28-1_1 D28-1_2 ... D30-8_93 D30-8_94 ## colData names(4): label donor plate sizeFactor ## reducedDimNames(0): ## altExpNames(1): ERCC # Seeing the available labels in this dataset. table(sceM$label) ## ## acinar alpha beta delta duct endothelial ## 219 812 448 193 245 21 ## epsilon mesenchymal pp ## 3 80 101 We then set up our test dataset from Grun et al. (2016), applying some basic quality control as discusssed here and in Section @ref{interaction-with-quality-control}. We also compute the log-transformed values here, not because it is strictly necessary but so that we don’t have to keep on typing assay.type.test=1 in later calls to SingleR(). sceG &lt;- GrunPancreasData() sceG &lt;- addPerCellQC(sceG) qc &lt;- quickPerCellQC(colData(sceG), percent_subsets=&quot;altexps_ERCC_percent&quot;, batch=sceG$donor, subset=sceG$donor %in% c(&quot;D17&quot;, &quot;D7&quot;, &quot;D2&quot;)) sceG &lt;- sceG[,!qc$discard] sceG &lt;- logNormCounts(sceG) sceG ## class: SingleCellExperiment ## dim: 20064 1064 ## metadata(0): ## assays(2): counts logcounts ## rownames(20064): A1BG-AS1__chr19 A1BG__chr19 ... ZZEF1__chr17 ## ZZZ3__chr1 ## rowData names(2): symbol chr ## colnames(1064): D2ex_1 D2ex_2 ... D17TGFB_94 D17TGFB_95 ## colData names(13): donor sample ... total sizeFactor ## reducedDimNames(0): ## altExpNames(1): ERCC We run SingleR() as described previously but with a marker detection mode that considers the variance of expression across cells. Here, we will use the Wilcoxon ranked sum test to identify the top markers for each pairwise comparison between labels. This is slower but more appropriate for single-cell data compared to the default marker detection algorithm, which may fail for low-coverage data where the median for each label is often zero. library(SingleR) pred.grun &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, de.method=&quot;wilcox&quot;) table(pred.grun$labels) ## ## acinar alpha beta delta duct endothelial ## 277 203 181 50 306 5 ## epsilon mesenchymal pp ## 1 22 19 By default, the function will take the top de.n (default: 10) genes from each pairwise comparison between labels. A larger number of markers increases the robustness of the annotation by ensuring that relevant genes are not omitted, especially if the reference dataset has study-specific effects that cause uninteresting genes to dominate the top set. However, this comes at the cost of increasing noise and computational time. library(SingleR) pred.grun &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, de.method=&quot;wilcox&quot;, de.n=50) table(pred.grun$labels) ## ## acinar alpha beta delta duct endothelial ## 275 203 177 55 307 5 ## epsilon mesenchymal pp ## 1 23 18 3.3 Defining custom markers The marker detection in SingleR() is built on top of the testing framework in scran, so most options in ?pairwiseWilcox and friends can be applied via the de.args= option. For example, we could use the \\(t\\)-test and test against a log-fold change threshold with de.args=list(lfc=1). library(SingleR) pred.grun2 &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, de.method=&quot;t&quot;, de.args=list(lfc=1)) table(pred.grun2$labels) ## ## acinar alpha beta delta duct endothelial ## 285 200 177 54 296 5 ## epsilon mesenchymal pp ## 5 24 18 However, users can also construct their own marker lists with any DE testing machinery. For example, we can perform pairwise binomial tests to identify genes that are differentially detected (i.e., have differences in the proportion of cells with non-zero counts) between labels in the reference Muraro dataset. We then take the top 10 marker genes from each pairwise comparison, obtaining a list of lists of character vectors containing the identities of the markers for that comparison. library(scran) out &lt;- pairwiseBinom(counts(sceM), sceM$label, direction=&quot;up&quot;) markers &lt;- getTopMarkers(out$statistics, out$pairs, n=10) # Upregulated in acinar compared to alpha: markers$acinar$alpha ## [1] &quot;KCNQ1__chr11&quot; &quot;FAM129A__chr1&quot; &quot;KLK1__chr19&quot; &quot;NTN4__chr12&quot; ## [5] &quot;RASEF__chr9&quot; &quot;CTRL__chr16&quot; &quot;LGALS2__chr22&quot; &quot;NUPR1__chr16&quot; ## [9] &quot;LGALS3__chr14&quot; &quot;NR5A2__chr1&quot; # Upregulated in alpha compared to acinar: markers$alpha$acinar ## [1] &quot;SLC38A4__chr12&quot; &quot;ARX__chrX&quot; &quot;CRYBA2__chr2&quot; &quot;FSTL5__chr4&quot; ## [5] &quot;GNG2__chr14&quot; &quot;NOL4__chr18&quot; &quot;IRX2__chr5&quot; &quot;KCNMB2__chr3&quot; ## [9] &quot;CFC1__chr2&quot; &quot;KCNJ6__chr21&quot; Once we have this list of lists, we supply it to SingleR() via the genes= argument, which causes the function to bypass the internal marker detection to use the supplied gene sets instead. The most obvious benefit of this approach is that the user can achieve greater control of the markers, allowing integration of prior biological knowledge to obtain more relevant genes and a more robust annotation. pred.grun2b &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, genes=markers) table(pred.grun2b$labels) ## ## acinar alpha beta delta duct endothelial ## 276 202 175 54 302 5 ## epsilon mesenchymal pp ## 2 25 23 In some cases, markers may only be available for specific labels rather than for pairwise comparisons between labels. This is accommodated by supplying a named list of character vectors to genes. Note that this is likely to be less powerful than the list-of-lists approach as information about pairwise differences is discarded. # Creating label-specific markers. label.markers &lt;- lapply(markers, unlist) label.markers &lt;- lapply(label.markers, unique) str(label.markers) ## List of 9 ## $ acinar : chr [1:40] &quot;KCNQ1__chr11&quot; &quot;FAM129A__chr1&quot; &quot;KLK1__chr19&quot; &quot;NTN4__chr12&quot; ... ## $ alpha : chr [1:41] &quot;SLC38A4__chr12&quot; &quot;ARX__chrX&quot; &quot;CRYBA2__chr2&quot; &quot;FSTL5__chr4&quot; ... ## $ beta : chr [1:47] &quot;ELAVL4__chr1&quot; &quot;PRUNE2__chr9&quot; &quot;NMNAT2__chr1&quot; &quot;PLCB4__chr20&quot; ... ## $ delta : chr [1:44] &quot;NOL4__chr18&quot; &quot;CABP7__chr22&quot; &quot;UNC80__chr2&quot; &quot;HEPACAM2__chr7&quot; ... ## $ duct : chr [1:50] &quot;ADCY5__chr3&quot; &quot;PDE3A__chr12&quot; &quot;SLC3A1__chr2&quot; &quot;BICC1__chr10&quot; ... ## $ endothelial: chr [1:26] &quot;GPR4__chr19&quot; &quot;TMEM204__chr16&quot; &quot;GPR116__chr6&quot; &quot;CYYR1__chr21&quot; ... ## $ epsilon : chr [1:14] &quot;BHMT__chr5&quot; &quot;JPH3__chr16&quot; &quot;SERPINA10__chr14&quot; &quot;UGT2B4__chr4&quot; ... ## $ mesenchymal: chr [1:34] &quot;TNFAIP6__chr2&quot; &quot;THBS2__chr6&quot; &quot;CDH11__chr16&quot; &quot;SRPX2__chrX&quot; ... ## $ pp : chr [1:44] &quot;SERTM1__chr13&quot; &quot;ETV1__chr7&quot; &quot;ARX__chrX&quot; &quot;ELAVL4__chr1&quot; ... pred.grun2c &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, genes=label.markers) table(pred.grun2c$labels) ## ## acinar alpha beta delta duct endothelial ## 262 204 169 59 317 6 ## epsilon mesenchymal pp ## 2 24 21 3.4 Pseudo-bulk aggregation Single-cell reference datasets provide a like-for-like comparison to our test single-cell datasets, yielding a more accurate classification of the cells in the latter (hopefully). However, there are frequently many more samples in single-cell references compared to bulk references, increasing the computational work involved in classification. We avoid this by aggregating cells into one “pseudo-bulk” sample per label (e.g., by averaging across log-expression values) and using those as the reference, which allows us to achieve the same efficiency as the use of bulk references. The obvious cost of this approach is that we discard potentially useful information about the distribution of cells within each label. Cells that belong to a heterogeneous population may not be correctly assigned if they are far from the population center. We attempt to preserve some of this information by using \\(k\\)-means clustering within each cell to create pseudo-bulk samples that are representative of a particular region of the expression space (i.e., vector quantization). We create \\(\\sqrt{N}\\) clusters given a label with \\(N\\) cells, which provides a reasonable compromise between reducing computational work and preserving the label’s internal distribution. To enable this aggregation, we simply set aggr.ref=TRUE in the SingleR() call. This uses the aggregateReference() function to perform \\(k\\)-means clustering within each label (typically after principal components analysis on the log-expression matrix, for greater speed) and average expression values for each within-label cluster. Note that marker detection is still performed on the unaggregated data so as to make full use of the distribution of expression values across cells. set.seed(100) # for the k-means step. pred.grun3 &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, de.method=&quot;wilcox&quot;, aggr.ref=TRUE) table(pred.grun3$labels) ## ## acinar alpha beta delta duct endothelial ## 277 202 184 47 306 5 ## epsilon mesenchymal pp ## 1 22 20 Obviously, the aggregation itself requires computational work so setting aggr.ref=TRUE in SingleR() itself may not improve speed. Rather, the real power of this approach lies in pre-aggregating the reference dataset so that it can be repeatedly applied to quickly annotate multiple test datasets. This approach is discussed in more detail in Chapter 7. Session information View session info R version 4.0.0 Patched (2020-05-01 r78341) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 18.04.4 LTS Matrix products: default BLAS: /home/luna/Software/R/R-4-0-branch-dev/lib/libRblas.so LAPACK: /home/luna/Software/R/R-4-0-branch-dev/lib/libRlapack.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] parallel stats4 stats graphics grDevices utils datasets [8] methods base other attached packages: [1] scran_1.17.0 SingleR_1.3.4 [3] scater_1.17.0 ggplot2_3.3.0 [5] scRNAseq_2.3.0 SingleCellExperiment_1.11.1 [7] SummarizedExperiment_1.19.4 DelayedArray_0.15.1 [9] matrixStats_0.56.0 Biobase_2.49.0 [11] GenomicRanges_1.41.1 GenomeInfoDb_1.25.0 [13] IRanges_2.23.4 S4Vectors_0.27.6 [15] BiocGenerics_0.35.2 BiocStyle_2.17.0 [17] rebook_0.99.0 loaded via a namespace (and not attached): [1] bitops_1.0-6 bit64_0.9-7 [3] httr_1.4.1 tools_4.0.0 [5] R6_2.4.1 irlba_2.3.3 [7] vipor_0.4.5 DBI_1.1.0 [9] colorspace_1.4-1 withr_2.2.0 [11] gridExtra_2.3 tidyselect_1.1.0 [13] processx_3.4.2 bit_1.1-15.2 [15] curl_4.3 compiler_4.0.0 [17] graph_1.67.0 BiocNeighbors_1.7.0 [19] bookdown_0.19 scales_1.1.1 [21] callr_3.4.3 rappdirs_0.3.1 [23] stringr_1.4.0 digest_0.6.25 [25] rmarkdown_2.1 XVector_0.29.0 [27] pkgconfig_2.0.3 htmltools_0.4.0 [29] limma_3.45.0 dbplyr_1.4.3 [31] fastmap_1.0.1 rlang_0.4.6 [33] RSQLite_2.2.0 shiny_1.4.0.2 [35] DelayedMatrixStats_1.11.0 BiocParallel_1.23.0 [37] dplyr_0.8.5 RCurl_1.98-1.2 [39] magrittr_1.5 BiocSingular_1.5.0 [41] scuttle_0.99.6 GenomeInfoDbData_1.2.3 [43] Matrix_1.2-18 Rcpp_1.0.4.6 [45] ggbeeswarm_0.6.0 munsell_0.5.0 [47] viridis_0.5.1 lifecycle_0.2.0 [49] edgeR_3.31.0 stringi_1.4.6 [51] yaml_2.2.1 zlibbioc_1.35.0 [53] BiocFileCache_1.13.0 AnnotationHub_2.21.0 [55] grid_4.0.0 blob_1.2.1 [57] dqrng_0.2.1 promises_1.1.0 [59] ExperimentHub_1.15.0 crayon_1.3.4 [61] lattice_0.20-41 locfit_1.5-9.4 [63] CodeDepends_0.6.5 knitr_1.28 [65] ps_1.3.3 pillar_1.4.4 [67] igraph_1.2.5 codetools_0.2-16 [69] XML_3.99-0.3 glue_1.4.1 [71] BiocVersion_3.12.0 evaluate_0.14 [73] BiocManager_1.30.10 vctrs_0.3.0 [75] httpuv_1.5.2 gtable_0.3.0 [77] purrr_0.3.4 assertthat_0.2.1 [79] xfun_0.13 rsvd_1.0.3 [81] mime_0.9 xtable_1.8-4 [83] later_1.0.0 viridisLite_0.3.0 [85] tibble_3.0.1 AnnotationDbi_1.51.0 [87] beeswarm_0.2.3 memoise_1.1.0 [89] statmod_1.4.34 ellipsis_0.3.1 [91] interactiveDisplayBase_1.27.0 Bibliography "],
["annotation-diagnostics.html", "Chapter 4 Annotation diagnostics 4.1 Overview 4.2 Based on the scores within cells 4.3 Based on the deltas across cells 4.4 Based on marker gene expression Session information", " Chapter 4 Annotation diagnostics .aaron-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .aaron-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 4.1 Overview In addition to the labels, SingleR() returns a number of helpful diagnostics about the annotation process that can be used to determine whether the assignments are appropriate. Unambiguous assignments corroborated by expression of canonical markers add confidence to the results, while low-confidence assignments can then be pruned out to avoid adding noise to downstream analyses. This chapter will demonstrate some of these common sanity checks on the pancreas datasets from Chapter 3 (Muraro et al. 2016,Grun et al. (2016)). View history #--- loading-muraro ---# library(scRNAseq) sceM &lt;- MuraroPancreasData() sceM &lt;- sceM[,!is.na(sceM$label) &amp; sceM$label!=&quot;unclear&quot;] library(scater) sceM &lt;- logNormCounts(sceM) #--- loading-grun ---# sceG &lt;- GrunPancreasData() sceG &lt;- addPerCellQC(sceG) qc &lt;- quickPerCellQC(colData(sceG), percent_subsets=&quot;altexps_ERCC_percent&quot;, batch=sceG$donor, subset=sceG$donor %in% c(&quot;D17&quot;, &quot;D7&quot;, &quot;D2&quot;)) sceG &lt;- sceG[,!qc$discard] sceG &lt;- logNormCounts(sceG) #--- annotation ---# library(SingleR) pred.grun &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, de.method=&quot;wilcox&quot;) 4.2 Based on the scores within cells The most obvious diagnostic reported by SingleR() is the nested matrix of per-cell scores in the scores field. This contains the correlation-based scores prior to any fine-tuning for each cell (row) and reference label (column). Ideally, we would see unambiguous assignments where, for any given cell, one label’s score is clearly larger than the others. pred.grun$scores[1:10,] ## acinar alpha beta delta duct endothelial epsilon mesenchymal ## [1,] 0.6797 0.1463 0.1554 0.1029 0.4971 0.2030 0.04434 0.1848 ## [2,] 0.6832 0.1849 0.1611 0.1250 0.5133 0.2231 0.08909 0.2140 ## [3,] 0.6845 0.2032 0.2141 0.1875 0.5060 0.2286 0.08960 0.1961 ## [4,] 0.6472 0.2050 0.2115 0.1879 0.7300 0.2285 0.12107 0.2708 ## [5,] 0.6079 0.2285 0.2419 0.1938 0.6616 0.2659 0.16007 0.3228 ## [6,] 0.5816 0.2789 0.2611 0.2661 0.6827 0.2857 0.21781 0.3151 ## [7,] 0.5704 0.3268 0.2990 0.2618 0.6293 0.2947 0.20834 0.3263 ## [8,] 0.5692 0.2455 0.2152 0.2033 0.6495 0.2652 0.18469 0.2943 ## [9,] 0.6421 0.2101 0.1929 0.1894 0.7201 0.2795 0.14615 0.3142 ## [10,] 0.7153 0.2109 0.1747 0.1606 0.5896 0.1687 0.15639 0.1778 ## pp ## [1,] 0.08954 ## [2,] 0.11207 ## [3,] 0.15207 ## [4,] 0.14351 ## [5,] 0.18475 ## [6,] 0.21898 ## [7,] 0.25871 ## [8,] 0.19160 ## [9,] 0.17281 ## [10,] 0.16314 To check whether this is indeed the case, we use the plotScoreHeatmap() function to visualize the score matrix (Figure 4.1). Here, the key is to examine the spread of scores within each cell, i.e., down the columns of the heatmap. Similar scores for a group of labels indicates that the assignment is uncertain for those columns, though this may be acceptable if the uncertainty is distributed across closely related cell types. library(SingleR) plotScoreHeatmap(pred.grun) Figure 4.1: Heatmap of normalized scores for the Grun dataset. Each cell is a column while each row is a label in the reference Muraro dataset. The final label (after fine-tuning) for each cell is shown in the top color bar. We can also display other metadata information for each cell by setting clusters= or annotation_col=. This is occasionally useful for examining potential batch effects, differences in cell type composition between conditions, relationship to clusters from an unsupervised analysis and so on,. For example, Figure 4.2 displays the donor of origin for each cell; we can see that each cell type has contributions from multiple donors, which is reassuring as it indicates that our assignments are not (purely) driven by donor effects. plotScoreHeatmap(pred.grun, annotation_col=as.data.frame(colData(sceG)[,&quot;donor&quot;,drop=FALSE])) Figure 4.2: Heatmap of normalized scores for the Grun dataset, including the donor of origin for each cell. The scores matrix has several caveats associated with its interpretation. Only the pre-tuned scores are stored in this matrix, as scores after fine-tuning are not comparable across all labels. This means that the label with the highest score for a cell may not be the cell’s final label if fine-tuning is applied. Moreover, the magnitude of differences in the scores has no clear interpretation; indeed, plotScoreHeatmap() dispenses with any faithful representation of the scores and instead adjusts the values to highlight any differences between labels within each cell. 4.3 Based on the deltas across cells We can identify poor-quality or ambiguous assignments based on the per-cell “delta”, i.e., the difference between the score for the assigned label and the median across all labels for each cell. Low deltas indicate that the assignment is uncertain, possibly because the cell’s true label does not exist in the reference. We use the delta rather than an absolute threshold on the score as the latter is more sensitive to technical effects. For example, changes in library size affect the technical noise and can increase/decrease all scores for a given cell, while the delta should be somewhat more robust as it focuses on the differences between scores. SingleR() will set a threshold on the delta for each label using an outlier-based strategy. Specifically, we identify cells with deltas that are small outliers relative to the deltas of other cells with the same label. This assumes that, for any given label, most cells assigned to that label are correct. We focus on outliers to avoid difficulties with setting a fixed threshold, especially given that the magnitudes of the deltas are about as uninterpretable as the scores themselves. Pruned labels are reported in the pruned.labels field where low-quality assignments are replaced with NA. to.remove &lt;- is.na(pred.grun$pruned.labels) table(Label=pred.grun$labels, Removed=to.remove) ## Removed ## Label FALSE TRUE ## acinar 251 26 ## alpha 198 5 ## beta 180 1 ## delta 49 1 ## duct 301 5 ## endothelial 4 1 ## epsilon 1 0 ## mesenchymal 22 0 ## pp 17 2 However, the default pruning parameters may not be appropriate for every dataset. For example, if one label is consistently misassigned, the assumption that most cells are correctly assigned will not be appropriate. In such cases, we can revert to a fixed threshold by manually calling the underlying pruneScores() function with min.diff.med=. The example below discards cells with deltas below an arbitrary threshold of 0.2, where higher thresholds correspond to greater assignment certainty. to.remove &lt;- pruneScores(pred.grun, min.diff.med=0.2) table(Label=pred.grun$labels, Removed=to.remove) ## Removed ## Label FALSE TRUE ## acinar 250 27 ## alpha 155 48 ## beta 148 33 ## delta 33 17 ## duct 301 5 ## endothelial 4 1 ## epsilon 0 1 ## mesenchymal 22 0 ## pp 4 15 This entire process can be visualized using the plotScoreDistribution() function, which displays the per-label distribution of the deltas across cells (Figure 4.3). We can check that outlier detection in pruneScores() behaved sensibly, and we might reconsider the reliability of labels with deltas close to zero. plotScoreDistribution(pred.grun, show = &quot;delta.med&quot;, ncol = 3, show.nmads = 3) Figure 4.3: Distribution of deltas for the Grun dataset. Each facet represents a label in the Muraro dataset, and each point represents a cell assigned to that label or assigned to that label and pruned. For comparison, the equivalent deltas for cells assigned to other labels are also shown. 4.4 Based on marker gene expression Another simple yet effective diagnostic is to examine the expression of the marker genes for each label in the test dataset. The marker genes used for each label are reported in the metadata() of the SingleR() output, so we can simply retrieve them to visualize their (usually log-transformed) expression values across the test dataset. Here, we use the plotHeatmap() function from scater to examine the expression of markers used to identify beta cells (Figure 4.4. all.markers &lt;- metadata(pred.grun)$de.genes sceG$labels &lt;- pred.grun$labels library(scater) plotHeatmap(sceG, order_columns_by=&quot;labels&quot;, features=unique(unlist(all.markers$beta))) Figure 4.4: Heatmap of log-expression values in the Grun dataset for all marker genes upregulated in beta cells in the Muraro reference dataset. Assigned labels for each cell are shown at the top. If a cell in the test dataset is confidently assigned to a particular label, we would expect it to have strong expression of that label’s markers. We would also hope that those label’s markers are biologically meaningful; in this case, we do observe strong upregulation of insulin (INS) in the beta cells, which is reassuring and gives greater confidence to the correctness of the assignment. If the identified markers are not meaningful or not consistently upregulated, some skepticism towards the quality of the assignments is warranted. It is straightforward to repeat this process for all labels by wrapping this code in a loop, as shown below in Figure 4.5. Note that plotHeatmap() is not the only function that can be used for this visualization; we could also use plotDots() to create a Seurat-style dot plot, or we could use other heatmap plotting functions such as dittoHeatmap() from dittoSeq. collected &lt;- list() for (lab in unique(pred.grun$labels)) { collected[[lab]] &lt;- plotHeatmap(sceG, silent=TRUE, order_columns_by=&quot;labels&quot;, main=lab, features=unique(unlist(all.markers[[lab]])))[[4]] } do.call(gridExtra::grid.arrange, collected) Figure 4.5: Heatmaps of log-expression values in the Grun dataset for all marker genes upregulated in each label in the Muraro reference dataset. Assigned labels for each cell are shown at the top. In general, the heatmap provides a more interpretable diagnostic visualization than the plots of scores and deltas. However, it does require more effort to inspect and may not be feasible for large numbers of labels. It is also difficult to use a heatmap to determine the correctness of assignment for closely related labels. Session information View session info R version 4.0.0 Patched (2020-05-01 r78341) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 18.04.4 LTS Matrix products: default BLAS: /home/luna/Software/R/R-4-0-branch-dev/lib/libRblas.so LAPACK: /home/luna/Software/R/R-4-0-branch-dev/lib/libRlapack.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 parallel stats graphics grDevices utils datasets [8] methods base other attached packages: [1] scater_1.17.0 ggplot2_3.3.0 [3] SingleCellExperiment_1.11.1 SingleR_1.3.2 [5] SummarizedExperiment_1.19.4 DelayedArray_0.15.1 [7] matrixStats_0.56.0 Biobase_2.49.0 [9] GenomicRanges_1.41.1 GenomeInfoDb_1.25.0 [11] IRanges_2.23.4 S4Vectors_0.27.6 [13] BiocGenerics_0.35.2 BiocStyle_2.17.0 [15] rebook_0.99.0 loaded via a namespace (and not attached): [1] bitops_1.0-6 bit64_0.9-7 [3] RColorBrewer_1.1-2 httr_1.4.1 [5] tools_4.0.0 R6_2.4.1 [7] irlba_2.3.3 vipor_0.4.5 [9] colorspace_1.4-1 DBI_1.1.0 [11] withr_2.2.0 gridExtra_2.3 [13] tidyselect_1.1.0 processx_3.4.2 [15] bit_1.1-15.2 curl_4.3 [17] compiler_4.0.0 graph_1.67.0 [19] BiocNeighbors_1.7.0 bookdown_0.19 [21] scales_1.1.1 callr_3.4.3 [23] rappdirs_0.3.1 stringr_1.4.0 [25] digest_0.6.25 rmarkdown_2.1 [27] XVector_0.29.0 pkgconfig_2.0.3 [29] htmltools_0.4.0 highr_0.8 [31] dbplyr_1.4.3 fastmap_1.0.1 [33] rlang_0.4.6 RSQLite_2.2.0 [35] shiny_1.4.0.2 DelayedMatrixStats_1.11.0 [37] farver_2.0.3 BiocParallel_1.23.0 [39] dplyr_0.8.5 RCurl_1.98-1.2 [41] magrittr_1.5 BiocSingular_1.5.0 [43] GenomeInfoDbData_1.2.3 Matrix_1.2-18 [45] ggbeeswarm_0.6.0 munsell_0.5.0 [47] Rcpp_1.0.4.6 viridis_0.5.1 [49] lifecycle_0.2.0 stringi_1.4.6 [51] yaml_2.2.1 zlibbioc_1.35.0 [53] BiocFileCache_1.13.0 AnnotationHub_2.21.0 [55] grid_4.0.0 blob_1.2.1 [57] promises_1.1.0 ExperimentHub_1.15.0 [59] crayon_1.3.4 lattice_0.20-41 [61] CodeDepends_0.6.5 knitr_1.28 [63] ps_1.3.3 pillar_1.4.4 [65] codetools_0.2-16 XML_3.99-0.3 [67] glue_1.4.1 BiocVersion_3.12.0 [69] evaluate_0.14 BiocManager_1.30.10 [71] vctrs_0.3.0 httpuv_1.5.2 [73] gtable_0.3.0 purrr_0.3.4 [75] assertthat_0.2.1 xfun_0.13 [77] rsvd_1.0.3 mime_0.9 [79] xtable_1.8-4 later_1.0.0 [81] viridisLite_0.3.0 pheatmap_1.0.12 [83] tibble_3.0.1 beeswarm_0.2.3 [85] AnnotationDbi_1.51.0 memoise_1.1.0 [87] ellipsis_0.3.1 interactiveDisplayBase_1.27.0 Bibliography "],
["using-multiple-references.html", "Chapter 5 Using multiple references 5.1 Overview 5.2 Using reference-specific labels 5.3 Using harmonized labels 5.4 Comparing scores across references Session info", " Chapter 5 Using multiple references .aaron-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .aaron-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 5.1 Overview In some cases, we may wish to use multiple references for annotation of a test dataset. This yields a more comprehensive set of cell types that are not covered by any individual reference, especially when differences in the resolution are considered. However, it is not trivial due to the presence of batch effects across references (from differences in technology, experimental protocol or the biological system) as well as differences in the annotation vocabulary between investigators. Several strategies are available to combine inferences from multiple references: using reference-specific labels in a combined reference using harmonized labels in a combined reference combining scores across multiple references This chapter discusses the various strengths and weaknesses of each strategy and provides some practical demonstrations of each. Here, we will use the HPCA and BlueprintEncode datasets as our references and (yet another) PBMC dataset as the test. library(TENxPBMCData) pbmc &lt;- TENxPBMCData(&quot;pbmc8k&quot;) library(SingleR) hpca &lt;- HumanPrimaryCellAtlasData(ensembl=TRUE) bpe &lt;- BlueprintEncodeData(ensembl=TRUE) 5.2 Using reference-specific labels In this strategy, each label is defined in the context of its reference dataset. This means that a label - say, “B cell” - in reference dataset X is considered to be different from a “B cell” label in reference dataset Y. Use of reference-specific labels is most appropriate if there are relevant biological differences between the references; for example, if one reference is concerned with healthy tissue while the other reference considers diseased tissue, it can be helpful to distinguish between the same cell type in different biological contexts. We can easily implement this approach by combining the expression matrices together and pasting the reference name onto the corresponding character vector of labels. This modification ensures that the downstream SingleR() call will treat each label-reference combination as a distinct entity. hpca2 &lt;- hpca hpca2$label.main &lt;- paste0(&quot;HPCA.&quot;, hpca2$label.main) bpe2 &lt;- bpe bpe2$label.main &lt;- paste0(&quot;BPE.&quot;, bpe2$label.main) shared &lt;- intersect(rownames(hpca2), rownames(bpe2)) combined &lt;- cbind(hpca2[shared,], bpe2[shared,]) It is then straightforward to perform annotation with the usual methods. com.res1 &lt;- SingleR(pbmc, ref=combined, labels=combined$label.main, assay.type.test=1) table(com.res1$labels) ## ## BPE.B-cells BPE.CD4+ T-cells BPE.CD8+ T-cells BPE.HSC ## 1178 1708 2656 20 ## BPE.Monocytes BPE.NK cells HPCA.HSC_-G-CSF HPCA.Platelets ## 2349 460 1 7 ## HPCA.T_cells ## 2 However, this strategy identifies markers by directly comparing expression values across references, meaning that the marker set is likely to contain genes responsible for uninteresting batch effects. This will increase noise during the calculation of the score in each reference, possibly leading to a loss of precision and a greater risk of technical variation dominating the classification results. It also complicates interpretation as the cell type is always qualified by its reference of origin in the results. 5.3 Using harmonized labels This strategy also involves combining the reference datasets into a single matrix but the labels are now harmonized so that the same cell type is given the same label across references. This allows feature selection methods to identify robust sets of label-specific markers that are more likely to generalize to other datasets. It also simplifies interpretation as there is no need to worry about the reference of origin for each label. Many of the SingleR datasets already have their labels mapped to the Cell Ontology. This provides a standard vocabulary to refer to the same cell type across multiple references. To simplify interpretation, we set cell.ont=&quot;nonna&quot; to remove all samples that could not be mapped to the ontology. hpca.ont &lt;- HumanPrimaryCellAtlasData(ensembl=TRUE, cell.ont=&quot;nonna&quot;) bpe.ont &lt;- BlueprintEncodeData(ensembl=TRUE, cell.ont=&quot;nonna&quot;) shared &lt;- intersect(rownames(hpca.ont), rownames(bpe.ont)) combined.ont &lt;- cbind(hpca.ont[shared,], bpe.ont[shared,]) combined.ont$source &lt;- rep(c(&quot;HPCA&quot;, &quot;BPE&quot;), c(ncol(hpca.ont), ncol(bpe.ont))) # Showing the top 10 most frequent terms: tab &lt;- table(combined.ont$label.ont, combined.ont$source) head(tab[order(rowSums(tab), decreasing=TRUE),]) ## ## BPE HPCA ## CL:0000235 18 83 ## CL:0000576 16 57 ## CL:0000451 1 57 ## CL:0000134 0 55 ## CL:0000775 23 21 ## CL:0002618 0 42 We perform annotation with SingleR() as previously described. We set the block= argument in de.args= so as to indicate that DE genes should only be performed within each reference, and then the statistics merged across references to identify the top markers. This ensures that we do not directly compare expression values across references, which reduces the susceptibility of the marker detection to batch effects. # TODO: add blocking mode for default marker detection. com.res2 &lt;- SingleR(pbmc, ref=combined.ont, labels=combined.ont$label.ont, assay.type.test=1) tab &lt;- table(com.res2$labels) head(sort(tab, decreasing=TRUE)) ## ## CL:0000624 CL:0000576 CL:0000788 CL:0000815 CL:0000623 CL:0000625 ## 2571 2200 899 681 646 426 The most obvious problem with this approach is that it assumes that harmonized labels are available. This is not always the case due to the use of different (often author-specific!) naming schemes, which requires at best semi-automated mapping of the author-derived labels to the standard vocabulary. The mapping process also runs the risk of discarding relevant information about the biological status (e.g., activation status, disease condition) if there is no obvious counterpart for that state in the ontology. 5.4 Comparing scores across references The final strategy - and the default approach implemented in SingleR() - involves performing classification separately within each reference, and then collating the results to choose the label with the highest score across references. This is a relatively expedient approach that avoids the need for explicit harmonization while also reducing exposure to reference-specific batch effects. Use of this approach simply involves passing multiple objects to the ref= and label= argument in SingleR(). This instructs the function to annotate the test dataset with each reference individually; it then collects the best labels for each cell across all references and identifies the overall best-scoring label as the final prediction for that cell. The second step requires a recomputation of scores across a subset of relevant markers to ensure that these scores are comparable across references. com.res3 &lt;- SingleR(test = pbmc, assay.type.test=1, ref = list(BPE=bpe, HPCA=hpca), labels = list(bpe$label.main, hpca$label.main)) table(com.res3$labels) ## ## B_cell B-cells CD4+ T-cells CD8+ T-cells ## 14 1170 1450 2936 ## GMP HSC Monocyte Monocytes ## 1 22 753 1560 ## NK cells NK_cell Platelets Pre-B_cell_CD34- ## 372 10 9 16 ## T_cells ## 68 The main appeal of this approach lies in the fact that it is based on the results of annotation with individual references. This avoids batch effects from comparing expression values across references; it reduces the need for any coordination in the label scheme between references; and simultaneously provides the per-reference annotations in the results. The last feature is particularly useful as it allows for more detailed diagnostics, troubleshooting and further analysis. head(com.res3$orig.results$BPE$labels) ## [1] &quot;B-cells&quot; &quot;Monocytes&quot; &quot;CD8+ T-cells&quot; &quot;CD8+ T-cells&quot; &quot;Monocytes&quot; ## [6] &quot;Monocytes&quot; head(com.res3$orig.results$HPCA$labels) ## [1] &quot;B_cell&quot; &quot;Monocyte&quot; &quot;T_cells&quot; &quot;T_cells&quot; &quot;Monocyte&quot; &quot;Monocyte&quot; The main downside is that it is somewhat suboptimal if there are many reference-specific labels, as markers are not identified with the aim of distinguishing a label in one reference from another label in another reference. The lack of harmonization in the labels also complicates interpretation of the results, though this can be addressed in the same manner as described above (i.e., replacing label.main with label.ont). Session info View session info R version 4.0.0 Patched (2020-05-01 r78341) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 18.04.4 LTS Matrix products: default BLAS: /home/luna/Software/R/R-4-0-branch-dev/lib/libRblas.so LAPACK: /home/luna/Software/R/R-4-0-branch-dev/lib/libRlapack.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] parallel stats4 stats graphics grDevices utils datasets [8] methods base other attached packages: [1] ensembldb_2.13.1 AnnotationFilter_1.13.0 [3] GenomicFeatures_1.41.0 AnnotationDbi_1.51.0 [5] SingleR_1.3.4 TENxPBMCData_1.7.0 [7] HDF5Array_1.17.0 rhdf5_2.33.0 [9] SingleCellExperiment_1.11.1 SummarizedExperiment_1.19.4 [11] DelayedArray_0.15.1 matrixStats_0.56.0 [13] Biobase_2.49.0 GenomicRanges_1.41.1 [15] GenomeInfoDb_1.25.0 IRanges_2.23.4 [17] S4Vectors_0.27.6 BiocGenerics_0.35.2 [19] BiocStyle_2.17.0 rebook_0.99.0 loaded via a namespace (and not attached): [1] ProtGenerics_1.21.0 bitops_1.0-6 [3] bit64_0.9-7 progress_1.2.2 [5] httr_1.4.1 tools_4.0.0 [7] R6_2.4.1 irlba_2.3.3 [9] lazyeval_0.2.2 DBI_1.1.0 [11] prettyunits_1.1.1 tidyselect_1.1.0 [13] processx_3.4.2 bit_1.1-15.2 [15] curl_4.3 compiler_4.0.0 [17] graph_1.67.0 BiocNeighbors_1.7.0 [19] rtracklayer_1.49.1 bookdown_0.19 [21] askpass_1.1 callr_3.4.3 [23] rappdirs_0.3.1 Rsamtools_2.5.0 [25] stringr_1.4.0 digest_0.6.25 [27] rmarkdown_2.1 XVector_0.29.0 [29] pkgconfig_2.0.3 htmltools_0.4.0 [31] dbplyr_1.4.3 fastmap_1.0.1 [33] rlang_0.4.6 RSQLite_2.2.0 [35] shiny_1.4.0.2 DelayedMatrixStats_1.11.0 [37] BiocParallel_1.23.0 dplyr_0.8.5 [39] RCurl_1.98-1.2 magrittr_1.5 [41] BiocSingular_1.5.0 GenomeInfoDbData_1.2.3 [43] Matrix_1.2-18 Rcpp_1.0.4.6 [45] Rhdf5lib_1.11.0 lifecycle_0.2.0 [47] stringi_1.4.6 yaml_2.2.1 [49] zlibbioc_1.35.0 BiocFileCache_1.13.0 [51] AnnotationHub_2.21.0 grid_4.0.0 [53] blob_1.2.1 promises_1.1.0 [55] ExperimentHub_1.15.0 crayon_1.3.4 [57] lattice_0.20-41 beachmat_2.5.0 [59] Biostrings_2.57.0 hms_0.5.3 [61] CodeDepends_0.6.5 knitr_1.28 [63] ps_1.3.3 pillar_1.4.4 [65] codetools_0.2-16 biomaRt_2.45.0 [67] XML_3.99-0.3 glue_1.4.1 [69] BiocVersion_3.12.0 evaluate_0.14 [71] BiocManager_1.30.10 vctrs_0.3.0 [73] httpuv_1.5.2 openssl_1.4.1 [75] purrr_0.3.4 assertthat_0.2.1 [77] xfun_0.13 rsvd_1.0.3 [79] mime_0.9 xtable_1.8-4 [81] later_1.0.0 tibble_3.0.1 [83] GenomicAlignments_1.25.0 memoise_1.1.0 [85] ellipsis_0.3.1 interactiveDisplayBase_1.27.0 "],
["harmonizing-labels.html", "Chapter 6 Harmonizing labels", " Chapter 6 Harmonizing labels The matchReferences() function provides a simple yet elegant approach for label harmonization between two references. Each reference is used to annotate the other and the probability of mutual assignment between each pair of labels is computed. Probabilities close to 1 indicate there is a 1:1 relation between that pair of labels; on the other hand, an all-zero probability vector indicates that a label is unique to a particular reference. library(SingleR) bp.se &lt;- BlueprintEncodeData() hpca.se &lt;- HumanPrimaryCellAtlasData() matched &lt;- matchReferences(bp.se, hpca.se, bp.se$label.main, hpca.se$label.main) pheatmap::pheatmap(matched, col=viridis::plasma(100)) A heatmap like the one above can be used to guide harmonization to enforce a consistent vocabulary across all labels representing the same cell type or state. The most obvious benefit of harmonization is that interpretation of the results is simplified. However, an even more important effect is that the presence of harmonized labels from multiple references allows the classification machinery to protect against irrelevant batch effects between references. For example, in SingleR()’s case, marker genes are favored if they are consistently upregulated across multiple references, improving robustness to technical idiosyncrasies in any test dataset. We stress that some manual intervention is still required in this process, given the risks posed by differences in biological systems and technologies. For example, neurons are considered unique to each reference while smooth muscle cells in the HPCA data are incorrectly matched to fibroblasts in the Blueprint/ENCODE data. CD4+ and CD8+ T cells are also both assigned to “T cells”, so some decision about the acceptable resolution of the harmonized labels is required here. As an aside, we can also use this function to identify the matching clusters between two independent scRNA-seq analyses. This is an “off-label” use that involves substituting the cluster assignments as proxies for the labels. We can then match up clusters and integrate conclusions from multiple datasets without the difficulty of batch correction and reclustering. "],
["advanced-options.html", "Chapter 7 Advanced options 7.1 Preconstructed indices 7.2 Parallelization 7.3 Approximate algorithms Session information", " Chapter 7 Advanced options .aaron-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .aaron-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 7.1 Preconstructed indices Advanced users can split the SingleR() workflow into two separate training and classification steps. This means that training (e.g., marker detection, assembling of nearest-neighbor indices) only needs to be performed once. The resulting data structures can then be re-used across multiple classifications with different test datasets, provided the gene annotation in the test dataset is identical to or a superset of the genes in the training set. To illustrate, we will consider the DICE reference dataset (Schmiedel et al. 2018). library(SingleR) dice &lt;- DatabaseImmuneCellExpressionData(ensembl=TRUE) dice ## class: SummarizedExperiment ## dim: 29914 1561 ## metadata(0): ## assays(1): logcounts ## rownames(29914): ENSG00000121410 ENSG00000268895 ... ENSG00000159840 ## ENSG00000074755 ## rowData names(0): ## colnames(1561): TPM_1 TPM_2 ... TPM_101 TPM_102 ## colData names(3): label.main label.fine label.ont table(dice$label.fine) ## ## B cells, naive Monocytes, CD14+ ## 106 106 ## Monocytes, CD16+ NK cells ## 105 105 ## T cells, CD4+, memory TREG T cells, CD4+, naive ## 104 103 ## T cells, CD4+, naive TREG T cells, CD4+, naive, stimulated ## 104 102 ## T cells, CD4+, TFH T cells, CD4+, Th1 ## 104 104 ## T cells, CD4+, Th1_17 T cells, CD4+, Th17 ## 104 104 ## T cells, CD4+, Th2 T cells, CD8+, naive ## 104 104 ## T cells, CD8+, naive, stimulated ## 102 Let’s say we want to use the DICE reference to annotate the PBMC dataset from Chapter 1. library(TENxPBMCData) sce &lt;- TENxPBMCData(&quot;pbmc3k&quot;) We use the trainSingleR() function to do all the necessary calculations that are independent of the test dataset. (Almost; see comments below about common.) This yields a list of various components that contains all identified marker genes and precomputed rank indices to be used in the score calculation. We can also turn on aggregation with aggr.ref=TRUE as described in Chapter 3. common &lt;- intersect(rownames(sce), rownames(dice)) set.seed(2000) trained &lt;- trainSingleR(dice[common,], labels=dice$label.fine, aggr.ref=TRUE) It is then a simple matter to use the trained object to annotate our dataset of interest through the classifySingleR() function. As we can see, this yields exactly the same result as applying SingleR() directly; however, the advantage here is that trained can be re-used for multiple classifySingleR() calls - possibly on different datasets - without having to repeat unnecessary steps when the reference is unchanged. pred &lt;- classifySingleR(sce, trained, assay.type=1) table(pred$labels) ## ## B cells, naive Monocytes, CD14+ ## 346 514 ## Monocytes, CD16+ NK cells ## 187 325 ## T cells, CD4+, memory TREG T cells, CD4+, naive ## 163 97 ## T cells, CD4+, naive TREG T cells, CD4+, TFH ## 41 456 ## T cells, CD4+, Th1 T cells, CD4+, Th1_17 ## 180 73 ## T cells, CD4+, Th17 T cells, CD4+, Th2 ## 60 46 ## T cells, CD8+, naive ## 212 # Comparing to the direct approach. set.seed(2000) direct &lt;- SingleR(sce, ref=dice, labels=dice$label.fine, assay.type.test=1, aggr.ref=TRUE) identical(pred$labels, direct$labels) ## [1] TRUE The big caveat is that the universe of genes in the test dataset cannot be greater than that in the reference. This is the reason behind the intersection to common genes and the subsequent subsetting of dice. Practical use of preconstructed indices is best combined with some prior information about the gene-level annotation; for example, we might know that we always use a particular version of the Ensembl gene models, so we would filter out any genes in the reference dataset that are not in the Ensembl annotation. 7.2 Parallelization Parallelization is an obvious approach to increasing annotation throughput. This is done using the framework in the BiocParallel package, which provides several options for parallelization depending on the available hardware. On POSIX-compliant systems (i.e., Linux and MacOS), the simplest method is to use forking by passing MulticoreParam() to the BPPARAM= argument: library(BiocParallel) pred2a &lt;- SingleR(sce, ref=dice, assay.type.test=1, labels=dice$label.fine, BPPARAM=MulticoreParam(8)) # 8 CPUs. Alternatively, one can use separate processes with SnowParam(), which is slower but can be used on all systems - including Windows, our old nemesis. pred2b &lt;- SingleR(sce, ref=dice, assay.type.test=1, labels=dice$label.fine, BPPARAM=SnowParam(8)) identical(pred$labels, pred2b$labels) ## [1] FALSE When working on a cluster, the BatchtoolsParam() function allows SingleR() to seamlessly interface with various job schedulers like SLURM, LSF and so on. This permits heavy-duty parallelization across hundreds of CPUs for highly intensive jobs, though often some configuration is required - see the vignette for more details. 7.3 Approximate algorithms It is possible to sacrifice accuracy to squeeze more speed out of SingleR. The most obvious approach is to simply turn off the fine-tuning with fine.tune=FALSE, which avoids the time-consuming fine-tuning iterations. When the reference labels are well-separated, this is probably an acceptable trade-off. pred3a &lt;- SingleR(sce, ref=dice, assay.type.test=1, labels=dice$label.main, fine.tune=FALSE) table(pred3a$labels) ## ## B cells Monocytes NK cells T cells, CD4+ T cells, CD8+ ## 348 705 357 950 340 Another approximation is based on the fact that the initial score calculation is done using a nearest-neighbors search. By default, this is an exact seach but we can switch to an approximate algorithm via the BNPARAM= argument. In the example below, we use the Annoy algorithm via the BiocNeighbors framework, which yields mostly similar results. (Note, though, that the Annoy method does involve a considerable amount of overhead, so for small jobs it will actually be slower than the exact search.) library(BiocNeighbors) pred3b &lt;- SingleR(sce, ref=dice, assay.type.test=1, labels=dice$label.main, fine.tune=FALSE, # for comparison with pred3a. BNPARAM=AnnoyParam()) table(pred3a$labels, pred3b$labels) ## ## B cells Monocytes NK cells T cells, CD4+ T cells, CD8+ ## B cells 348 0 0 0 0 ## Monocytes 0 705 0 0 0 ## NK cells 0 0 357 0 0 ## T cells, CD4+ 0 0 0 950 0 ## T cells, CD8+ 0 0 0 0 340 Session information View session info R version 4.0.0 Patched (2020-05-01 r78341) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 18.04.4 LTS Matrix products: default BLAS: /home/luna/Software/R/R-4-0-branch-dev/lib/libRblas.so LAPACK: /home/luna/Software/R/R-4-0-branch-dev/lib/libRlapack.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 parallel stats graphics grDevices utils datasets [8] methods base other attached packages: [1] BiocNeighbors_1.7.0 BiocParallel_1.23.0 [3] TENxPBMCData_1.7.0 HDF5Array_1.17.0 [5] rhdf5_2.33.0 SingleCellExperiment_1.11.1 [7] ensembldb_2.13.1 AnnotationFilter_1.13.0 [9] GenomicFeatures_1.41.0 AnnotationDbi_1.51.0 [11] SingleR_1.3.4 SummarizedExperiment_1.19.4 [13] DelayedArray_0.15.1 matrixStats_0.56.0 [15] Biobase_2.49.0 GenomicRanges_1.41.1 [17] GenomeInfoDb_1.25.0 IRanges_2.23.4 [19] S4Vectors_0.27.6 BiocGenerics_0.35.2 [21] BiocStyle_2.17.0 rebook_0.99.0 loaded via a namespace (and not attached): [1] ProtGenerics_1.21.0 bitops_1.0-6 [3] bit64_0.9-7 progress_1.2.2 [5] httr_1.4.1 tools_4.0.0 [7] R6_2.4.1 irlba_2.3.3 [9] lazyeval_0.2.2 DBI_1.1.0 [11] prettyunits_1.1.1 tidyselect_1.1.0 [13] processx_3.4.2 bit_1.1-15.2 [15] curl_4.3 compiler_4.0.0 [17] graph_1.67.0 rtracklayer_1.49.1 [19] bookdown_0.19 askpass_1.1 [21] callr_3.4.3 rappdirs_0.3.1 [23] Rsamtools_2.5.0 stringr_1.4.0 [25] digest_0.6.25 rmarkdown_2.1 [27] XVector_0.29.0 pkgconfig_2.0.3 [29] htmltools_0.4.0 dbplyr_1.4.3 [31] fastmap_1.0.1 rlang_0.4.6 [33] RSQLite_2.2.0 shiny_1.4.0.2 [35] DelayedMatrixStats_1.11.0 dplyr_0.8.5 [37] RCurl_1.98-1.2 magrittr_1.5 [39] BiocSingular_1.5.0 GenomeInfoDbData_1.2.3 [41] Matrix_1.2-18 Rhdf5lib_1.11.0 [43] Rcpp_1.0.4.6 lifecycle_0.2.0 [45] stringi_1.4.6 yaml_2.2.1 [47] zlibbioc_1.35.0 BiocFileCache_1.13.0 [49] AnnotationHub_2.21.0 grid_4.0.0 [51] blob_1.2.1 promises_1.1.0 [53] ExperimentHub_1.15.0 crayon_1.3.4 [55] lattice_0.20-41 Biostrings_2.57.0 [57] hms_0.5.3 CodeDepends_0.6.5 [59] knitr_1.28 ps_1.3.3 [61] pillar_1.4.4 codetools_0.2-16 [63] biomaRt_2.45.0 XML_3.99-0.3 [65] glue_1.4.1 BiocVersion_3.12.0 [67] evaluate_0.14 BiocManager_1.30.10 [69] vctrs_0.3.0 httpuv_1.5.2 [71] openssl_1.4.1 purrr_0.3.4 [73] assertthat_0.2.1 xfun_0.13 [75] rsvd_1.0.3 mime_0.9 [77] xtable_1.8-4 later_1.0.0 [79] tibble_3.0.1 GenomicAlignments_1.25.0 [81] memoise_1.1.0 ellipsis_0.3.1 [83] interactiveDisplayBase_1.27.0 Bibliography "],
["cross-annotating-pancreas.html", "Chapter 8 Cross-annotating pancreas 8.1 Loading the data 8.2 Applying the annotation 8.3 Diagnostics Session information", " Chapter 8 Cross-annotating pancreas .aaron-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .aaron-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 8.1 Loading the data We load the Muraro et al. (2016) dataset as our reference, removing unlabelled cells or cells without a clear label. We also need to compute log-expression values for use in SingleR(). library(scRNAseq) sceM &lt;- MuraroPancreasData() sceM &lt;- sceM[,!is.na(sceM$label) &amp; sceM$label!=&quot;unclear&quot;] library(scater) sceM &lt;- logNormCounts(sceM) # Examining the distribution of labels in this reference. table(sceM$label) ## ## acinar alpha beta delta duct endothelial ## 219 812 448 193 245 21 ## epsilon mesenchymal pp ## 3 80 101 We load the Grun et al. (2016) dataset as our test, applying some basic quality control to remove low-quality cells in some of the batches (see here for details). Technically speaking, this does not need log-expression values but we compute them anyway for convenience. sceG &lt;- GrunPancreasData() sceG &lt;- addPerCellQC(sceG) qc &lt;- quickPerCellQC(colData(sceG), percent_subsets=&quot;altexps_ERCC_percent&quot;, batch=sceG$donor, subset=sceG$donor %in% c(&quot;D17&quot;, &quot;D7&quot;, &quot;D2&quot;)) sceG &lt;- sceG[,!qc$discard] sceG &lt;- logNormCounts(sceG) ncol(sceG) ## [1] 1064 8.2 Applying the annotation We apply SingleR() with Wilcoxon rank sum test-based marker detection to annotate the Grun dataset. library(SingleR) pred.grun &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, de.method=&quot;wilcox&quot;) We examine the distribution of predicted labels: table(pred.grun$labels) ## ## acinar alpha beta delta duct endothelial ## 277 203 181 50 306 5 ## epsilon mesenchymal pp ## 1 22 19 8.3 Diagnostics Session information prettySessionInfo() View session info R version 4.0.0 Patched (2020-05-01 r78341) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 18.04.4 LTS Matrix products: default BLAS: /home/luna/Software/R/R-4-0-branch-dev/lib/libRblas.so LAPACK: /home/luna/Software/R/R-4-0-branch-dev/lib/libRlapack.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] parallel stats4 stats graphics grDevices utils datasets [8] methods base other attached packages: [1] SingleR_1.3.2 scater_1.17.0 [3] ggplot2_3.3.0 scRNAseq_2.3.0 [5] SingleCellExperiment_1.11.1 SummarizedExperiment_1.19.4 [7] DelayedArray_0.15.1 matrixStats_0.56.0 [9] Biobase_2.49.0 GenomicRanges_1.41.1 [11] GenomeInfoDb_1.25.0 IRanges_2.23.4 [13] S4Vectors_0.27.6 BiocGenerics_0.35.2 [15] BiocStyle_2.17.0 rebook_0.99.0 loaded via a namespace (and not attached): [1] bitops_1.0-6 bit64_0.9-7 [3] httr_1.4.1 tools_4.0.0 [5] R6_2.4.1 irlba_2.3.3 [7] vipor_0.4.5 DBI_1.1.0 [9] colorspace_1.4-1 withr_2.2.0 [11] gridExtra_2.3 tidyselect_1.1.0 [13] processx_3.4.2 bit_1.1-15.2 [15] curl_4.3 compiler_4.0.0 [17] graph_1.67.0 BiocNeighbors_1.7.0 [19] bookdown_0.19 scales_1.1.1 [21] callr_3.4.3 rappdirs_0.3.1 [23] stringr_1.4.0 digest_0.6.25 [25] rmarkdown_2.1 XVector_0.29.0 [27] pkgconfig_2.0.3 htmltools_0.4.0 [29] limma_3.45.0 dbplyr_1.4.3 [31] fastmap_1.0.1 rlang_0.4.6 [33] RSQLite_2.2.0 shiny_1.4.0.2 [35] DelayedMatrixStats_1.11.0 BiocParallel_1.23.0 [37] dplyr_0.8.5 RCurl_1.98-1.2 [39] magrittr_1.5 BiocSingular_1.5.0 [41] scuttle_0.99.6 GenomeInfoDbData_1.2.3 [43] Matrix_1.2-18 Rcpp_1.0.4.6 [45] ggbeeswarm_0.6.0 munsell_0.5.0 [47] viridis_0.5.1 lifecycle_0.2.0 [49] edgeR_3.31.0 stringi_1.4.6 [51] yaml_2.2.1 zlibbioc_1.35.0 [53] BiocFileCache_1.13.0 AnnotationHub_2.21.0 [55] grid_4.0.0 blob_1.2.1 [57] dqrng_0.2.1 promises_1.1.0 [59] ExperimentHub_1.15.0 crayon_1.3.4 [61] lattice_0.20-41 locfit_1.5-9.4 [63] CodeDepends_0.6.5 knitr_1.28 [65] ps_1.3.3 pillar_1.4.4 [67] igraph_1.2.5 codetools_0.2-16 [69] XML_3.99-0.3 glue_1.4.1 [71] BiocVersion_3.12.0 evaluate_0.14 [73] scran_1.17.0 BiocManager_1.30.10 [75] vctrs_0.3.0 httpuv_1.5.2 [77] gtable_0.3.0 purrr_0.3.4 [79] assertthat_0.2.1 xfun_0.13 [81] rsvd_1.0.3 mime_0.9 [83] xtable_1.8-4 later_1.0.0 [85] viridisLite_0.3.0 tibble_3.0.1 [87] AnnotationDbi_1.51.0 beeswarm_0.2.3 [89] memoise_1.1.0 statmod_1.4.34 [91] ellipsis_0.3.1 interactiveDisplayBase_1.27.0 Bibliography "],
["contributors.html", "Chapter 9 Contributors", " Chapter 9 Contributors Aaron Lun An ancient interdimensional horror who has recently awoken from his aeons-long slumber. His true name cannot be pronounced by the human tongue and his true form cannot be grasped by the human mind. It is said that, when the stars are right, he will herald the return of the Old Ones to plunge the world into darkness once more. In the meantime, he maintains about 20 Bioconductor packages for analyzing a range of genomics data modalities. "],
["bibliography.html", "Chapter 10 Bibliography", " Chapter 10 Bibliography "]
]
