[
["index.html", "Assigning cell types with SingleR Preface", " Assigning cell types with SingleR 2020-05-13 Preface Imagine a world without a reference genome. Whenever you receive new sequencing data - and we’ll just talk about transcriptomic data for now - you’ll have to run it through an assembler to characterize the genes that are being expressed. If you’re lucky enough to get a decent assembly that isn’t confused by contamination or homologous sequences, it falls on you to pick through the sequence to figure out what what the gene actually is. (BH3 domain? Probably pro-apoptotic. Homeobox domain? Something to do with development.) And if you’re at a conference and you hear the name of a gene you’re working on, how can you be sure that everyone’s talking about the same thing? Now, this particular hellscape only exists in nightmares and history books, but it’s easy to see the parallels with single-cell data analyses; simply replace reads with cells, assemblies with clusters, and genes with cell types. In the single-cell analysis field, a typical practitioner will hope that their clusters are reasonable proxies for the biological states of interest (a strong assumption indeed!) and that their manual annotation of the clusters is accurate (which is itself dependent on domain expertise, coffee consumption and grant application deadlines). The current process of clustering, looking at a handful of markers and making a guesstimate of the cell type is best described as “artisanal” - which is not inherently bad, but one would hope that a mature technology would not require so much manual intervention for its routine use. A useful life philosophy is that hard work is a disease for which automation is the cure, and this case is no exception. Automated cell type annotation methods match cells in a new dataset against curated reference profiles of known cell types, assigning each cell to the type that its expression profile is most similar to. This allows users to skip the mundane annotation of their data and jump directly to the interesting questions - does my cell type change in abundance or expression across treatments? Is there interesting substructure within an existing population? In this respect, automated annotation methods are the single-cell field’s equivalent to genome aligners; the latter are an integral part of almost all sequencing analysis pipelines, regarded in the same light as electricity, internet and running water. This book covers the use of SingleR, one implementation of an automated annotation method. If you want a survey of different annotation methods - this book is not for you. If you want to create hand-crafted cluster definitions - this book is not for you. (Read the other one instead.) If you want to use the pre-Bioconductor version of the package - this book is not for you. But if you’re tired of manually annotating your single-cell data and you want to do something better with your life, then read on, because SingleR is the enemy of pointless hard work. "],
["introduction.html", "Chapter 1 Introduction 1.1 Motivation 1.2 Method description 1.3 Quick start 1.4 Where to get help Session information", " Chapter 1 Introduction 1.1 Motivation The Bioconductor package SingleR implements an automatic annotation method for single-cell RNA sequencing (scRNA-seq) data (Aran et al. 2019). Given a reference dataset of samples (single-cell or bulk) with known labels, it assigns those labels to new cells from a test dataset based on similarities in their expression profiles. This provides a convenient way of transferring biological knowledge across datasets. allowing users to leverage the domain expertise implicit in the creation of each reference. The most common application of SingleR involves predicting cell type (or “state”, or “kind”) in a new dataset, a process that is facilitated by the availability of built-in references and compatibility with user-supplied datasets. In this manner, the burden of manually interpreting clusters and defining marker genes only has to be done once, for the reference dataset, and this knowledge can be propagated to new datasets in an automated manner. 1.2 Method description SingleR can be considered a robust variant of nearest-neighbors classification, with some tweaks to improve resolution for closely related labels. For each test cell: We compute the Spearman correlation between its expression profile and that of each reference sample. The use of Spearman’s correlation provides a measure of robustness to batch effects across datasets. The calculation only uses the union of marker genes identified by pairwise comparisons between labels in the reference data, so as to improve resolution of separation between labels. We define the per-label score as a fixed quantile (by default, 0.8) of the correlations across all samples with that label. This accounts for differences in the number of reference samples for each label, which interferes with simpler flavors of nearest neighbor classification; it also avoids penalizing classifications to heterogeneous labels by only requiring a good match to a minority of samples. We repeat the score calculation for all labels in the reference dataset. The label with the highest score is used as SingleR’s prediction for this cell. We optionally perform a fine-tuning step to improve resolution between closely related labels. The reference dataset is subsetted to only include labels with scores close to the maximum, scores are recomputed using only marker genes for the subset of labels (thus focusing on the most relevant features), and this is iterated until one label remains. 1.3 Quick start We will demonstrate the use of SingleR() on a classic 10X Genomics dataset (Zheng et al. 2017) with the built-in Human Primary Cell Atlas dataset (Mabbott et al. 2013) as the reference. # Loading test data. library(TENxPBMCData) new.data &lt;- TENxPBMCData(&quot;pbmc4k&quot;) # Loading reference data with Ensembl annotations. library(SingleR) ref.data &lt;- HumanPrimaryCellAtlasData(ensembl=TRUE) # Performing predictions. predictions &lt;- SingleR(test=new.data, assay.type.test=1, ref=ref.data, labels=ref.data$label.main) table(predictions$labels) ## ## B_cell CMP DC GMP ## 606 8 1 2 ## Monocyte NK_cell Platelets Pre-B_cell_CD34- ## 1164 217 3 46 ## T_cells ## 2293 And that’s it, really. 1.4 Where to get help Questions on the general use of SingleR should be posted to the Bioconductor support site. Please send requests for general assistance and advice to the support site rather than to the individual authors. Bug reports or feature requests should be made to the GitHub repository; well-considered suggestions for improvements are always welcome. Session information sessionInfo() ## R version 4.0.0 Patched (2020-05-01 r78341) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 18.04.4 LTS ## ## Matrix products: default ## BLAS: /home/luna/Software/R/R-4-0-branch-dev/lib/libRblas.so ## LAPACK: /home/luna/Software/R/R-4-0-branch-dev/lib/libRlapack.so ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] parallel stats4 stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] ensembldb_2.13.0 AnnotationFilter_1.13.0 ## [3] GenomicFeatures_1.41.0 AnnotationDbi_1.51.0 ## [5] SingleR_1.3.1 TENxPBMCData_1.7.0 ## [7] HDF5Array_1.17.0 rhdf5_2.33.0 ## [9] SingleCellExperiment_1.11.1 SummarizedExperiment_1.19.2 ## [11] DelayedArray_0.15.1 matrixStats_0.56.0 ## [13] Biobase_2.49.0 GenomicRanges_1.41.1 ## [15] GenomeInfoDb_1.25.0 IRanges_2.23.4 ## [17] S4Vectors_0.27.4 BiocGenerics_0.35.1 ## [19] BiocStyle_2.17.0 ## ## loaded via a namespace (and not attached): ## [1] ProtGenerics_1.21.0 bitops_1.0-6 ## [3] bit64_0.9-7 progress_1.2.2 ## [5] httr_1.4.1 tools_4.0.0 ## [7] R6_2.4.1 irlba_2.3.3 ## [9] lazyeval_0.2.2 DBI_1.1.0 ## [11] tidyselect_1.0.0 prettyunits_1.1.1 ## [13] bit_1.1-15.2 curl_4.3 ## [15] compiler_4.0.0 BiocNeighbors_1.7.0 ## [17] rtracklayer_1.49.1 bookdown_0.18 ## [19] askpass_1.1 rappdirs_0.3.1 ## [21] stringr_1.4.0 digest_0.6.25 ## [23] Rsamtools_2.5.0 rmarkdown_2.1 ## [25] XVector_0.29.0 pkgconfig_2.0.3 ## [27] htmltools_0.4.0 dbplyr_1.4.3 ## [29] fastmap_1.0.1 rlang_0.4.6 ## [31] RSQLite_2.2.0 shiny_1.4.0.2 ## [33] DelayedMatrixStats_1.11.0 BiocParallel_1.23.0 ## [35] dplyr_0.8.5 RCurl_1.98-1.2 ## [37] magrittr_1.5 BiocSingular_1.5.0 ## [39] GenomeInfoDbData_1.2.3 Matrix_1.2-18 ## [41] Rcpp_1.0.4.6 Rhdf5lib_1.11.0 ## [43] lifecycle_0.2.0 stringi_1.4.6 ## [45] yaml_2.2.1 zlibbioc_1.35.0 ## [47] BiocFileCache_1.13.0 AnnotationHub_2.21.0 ## [49] grid_4.0.0 blob_1.2.1 ## [51] promises_1.1.0 ExperimentHub_1.15.0 ## [53] crayon_1.3.4 lattice_0.20-41 ## [55] beachmat_2.5.0 Biostrings_2.57.0 ## [57] hms_0.5.3 knitr_1.28 ## [59] pillar_1.4.4 codetools_0.2-16 ## [61] biomaRt_2.45.0 XML_3.99-0.3 ## [63] glue_1.4.0 BiocVersion_3.12.0 ## [65] evaluate_0.14 BiocManager_1.30.10 ## [67] vctrs_0.2.4 httpuv_1.5.2 ## [69] openssl_1.4.1 purrr_0.3.4 ## [71] assertthat_0.2.1 xfun_0.13 ## [73] rsvd_1.0.3 mime_0.9 ## [75] xtable_1.8-4 later_1.0.0 ## [77] tibble_3.0.1 GenomicAlignments_1.25.0 ## [79] memoise_1.1.0 ellipsis_0.3.0 ## [81] interactiveDisplayBase_1.27.0 Bibliography "],
["using-the-built-in-references.html", "Chapter 2 Using the built-in references 2.1 Overview 2.2 Annotation with default marker detection 2.3 Choices of assay data Session information", " Chapter 2 Using the built-in references 2.1 Overview SingleR detects markers in a pairwise manner between labels in the reference dataset. Specifically, for each label of interest, it performs pairwise comparisons to every other label in the reference and identifies the genes that are upregulated in the label of interest for each comparison. The initial score calculation is then performed on the union of marker genes across all comparisons for all label. This approach ensures that the selected subset of features will contain genes that distinguish each label from any other label. (In contrast, other approaches that treat the “other” labels as a single group do not offer this guarantee; see here for a discussion.) It also allows the fine-tuning step to aggressively improve resolution by only using marker genes from comparisons involving labels that both have scores close to the maximum. The original (“classic”) marker detection algorithm used in Aran et al. (2019) identified marker genes based on their log-fold changes in each pairwise comparison. Specifically, it used the genes with the largest positive differences in the per-label median log-expression values between labels. The number of genes taken from each pairwise comparison was defined as \\(500 (\\frac{2}{3})^{\\log_{2}(n)}\\), where \\(n\\) is the number of unique labels in the reference; this aimed to reduce the number of genes (and thus the computational time) as the number of labels and pairwise comparisons increased. It is primarily intended for reference datasets that have little or no replication, a description that covers most of the built-in references and precludes more complicated marker detection procedures (Chapter 3). 2.2 Annotation with default marker detection For demonstration purposes, we will use the Grun et al. (2016) haematopoietic stem cell (HSC) dataset from the scRNAseq package. The GrunHSCData() function conveniently returns a SingleCellExperiment object containing the count matrix for this dataset. library(scRNAseq) sce &lt;- GrunHSCData(ensembl=TRUE) sce ## class: SingleCellExperiment ## dim: 21817 1915 ## metadata(0): ## assays(1): counts ## rownames(21817): ENSMUSG00000109644 ENSMUSG00000007777 ... ## ENSMUSG00000055670 ENSMUSG00000039068 ## rowData names(3): symbol chr originalName ## colnames(1915): JC4_349_HSC_FE_S13_ JC4_350_HSC_FE_S13_ ... ## JC48P6_1203_HSC_FE_S8_ JC48P6_1204_HSC_FE_S8_ ## colData names(2): sample protocol ## reducedDimNames(0): ## altExpNames(0): Our plan is to annotate each cell with the built-in ImmGen reference dataset (Heng et al. 2008). Calling the ImmGenData() function returns a SummarizedExperiment object containing a matrix of log-expression values with sample-level labels. We set ensembl=TRUE to match the reference’s gene annotation with that in the sce object (the default is to use the gene symbol). library(SingleR) immgen &lt;- ImmGenData(ensembl=TRUE) immgen ## class: SummarizedExperiment ## dim: 21352 830 ## metadata(0): ## assays(1): logcounts ## rownames(21352): ENSMUSG00000079681 ENSMUSG00000066372 ... ## ENSMUSG00000034640 ENSMUSG00000036940 ## rowData names(0): ## colnames(830): ## GSM1136119_EA07068_260297_MOGENE-1_0-ST-V1_MF.11C-11B+.LU_1.CEL ## GSM1136120_EA07068_260298_MOGENE-1_0-ST-V1_MF.11C-11B+.LU_2.CEL ... ## GSM920654_EA07068_201214_MOGENE-1_0-ST-V1_TGD.VG4+24ALO.E17.TH_1.CEL ## GSM920655_EA07068_201215_MOGENE-1_0-ST-V1_TGD.VG4+24ALO.E17.TH_2.CEL ## colData names(3): label.main label.fine label.ont Technically speaking, each built-in dataset actually has three sets of labels that primarily differ in their resolution. For the purposes of this demonstration, we will use the “fine” labels in the label.fine metadata field. head(immgen$label.fine) ## [1] &quot;Macrophages (MF.11C-11B+)&quot; &quot;Macrophages (MF.11C-11B+)&quot; ## [3] &quot;Macrophages (MF.11C-11B+)&quot; &quot;Macrophages (MF.ALV)&quot; ## [5] &quot;Macrophages (MF.ALV)&quot; &quot;Macrophages (MF.ALV)&quot; Annotation is then a simple matter of calling SingleR() on our test (Grun) dataset and the reference (ImmGen) dataset, leaving the default of de.method=&quot;classic&quot; to use the original marker detection scheme. This applies the algorithm described in Section 1.2, returning a DataFrame where each row contains prediction results for a single cell in the sce object. Labels are shown before fine-tuning (first.labels), after fine-tuning (labels) and after pruning (pruned.labels), along with the associated scores for each label. # See &#39;Choices of assay data&#39; for &#39;assay.type.test=&#39; explanation. pred &lt;- SingleR(test = sce, ref = immgen, labels = immgen$label.fine, assay.type.test=1) pred ## DataFrame with 1915 rows and 5 columns ## scores ## &lt;matrix&gt; ## JC4_349_HSC_FE_S13_ 0.02170371:0.023365296: 0.02462244:... ## JC4_350_HSC_FE_S13_ 0.03127428:0.031426006: 0.03286075:... ## JC4_351_HSC_FE_S13_ 0.02485081:0.024722089: 0.02174789:... ## JC4_352_HSC_FE_S13_ 0.03612959:0.036907421: 0.03950824:... ## JC4_353_HSC_FE_S13_ 0.00246304:0.000508024:-0.00191648:... ## ... ... ## JC48P6_1200_HSC_FE_S8_ 0.192889:0.192199:0.191950:... ## JC48P6_1201_HSC_FE_S8_ 0.164670:0.161995:0.162909:... ## JC48P6_1202_HSC_FE_S8_ 0.162044:0.160878:0.158804:... ## JC48P6_1203_HSC_FE_S8_ 0.175933:0.178043:0.180334:... ## JC48P6_1204_HSC_FE_S8_ 0.204651:0.205074:0.203180:... ## first.labels tuning.scores ## &lt;character&gt; &lt;DataFrame&gt; ## JC4_349_HSC_FE_S13_ T cells (T.8EFF.OT1.48HR.LISOVA) 0.0465958:0.0458002 ## JC4_350_HSC_FE_S13_ Stem cells (SC.CMP.DR) 0.0457856:0.0438811 ## JC4_351_HSC_FE_S13_ Stem cells (SC.MEP) 0.0328072:0.0321104 ## JC4_352_HSC_FE_S13_ Stem cells (SC.MEP) 0.0511217:0.0509664 ## JC4_353_HSC_FE_S13_ Macrophages (MF.103-11B+.SALM3) 0.0183372:0.0168012 ## ... ... ... ## JC48P6_1200_HSC_FE_S8_ Stem cells (SC.LT34F) 0.236700:0.1178367 ## JC48P6_1201_HSC_FE_S8_ Stem cells (MLP) 0.341081:0.2547433 ## JC48P6_1202_HSC_FE_S8_ Stem cells (SC.LT34F) 0.160514:0.0955061 ## JC48P6_1203_HSC_FE_S8_ Stem cells (SC.LT34F) 0.500000:0.5000000 ## JC48P6_1204_HSC_FE_S8_ Stem cells (SC.LT34F) 0.161313:0.1437619 ## labels ## &lt;character&gt; ## JC4_349_HSC_FE_S13_ T cells (T.8EFF.OT1.48HR.LISOVA) ## JC4_350_HSC_FE_S13_ Stem cells (SC.CMP.DR) ## JC4_351_HSC_FE_S13_ Stem cells (SC.MEP) ## JC4_352_HSC_FE_S13_ Stem cells (SC.MEP) ## JC4_353_HSC_FE_S13_ Macrophages (MF.103-11B+.SALM3) ## ... ... ## JC48P6_1200_HSC_FE_S8_ Stem cells (SC.LT34F) ## JC48P6_1201_HSC_FE_S8_ Stem cells (SC.ST34F) ## JC48P6_1202_HSC_FE_S8_ Stem cells (SC.LT34F) ## JC48P6_1203_HSC_FE_S8_ Stem cells (SC.STSL) ## JC48P6_1204_HSC_FE_S8_ Stem cells (SC.STSL) ## pruned.labels ## &lt;character&gt; ## JC4_349_HSC_FE_S13_ T cells (T.8EFF.OT1.48HR.LISOVA) ## JC4_350_HSC_FE_S13_ Stem cells (SC.CMP.DR) ## JC4_351_HSC_FE_S13_ Stem cells (SC.MEP) ## JC4_352_HSC_FE_S13_ Stem cells (SC.MEP) ## JC4_353_HSC_FE_S13_ Macrophages (MF.103-11B+.SALM3) ## ... ... ## JC48P6_1200_HSC_FE_S8_ Stem cells (SC.LT34F) ## JC48P6_1201_HSC_FE_S8_ Stem cells (SC.ST34F) ## JC48P6_1202_HSC_FE_S8_ Stem cells (SC.LT34F) ## JC48P6_1203_HSC_FE_S8_ Stem cells (SC.STSL) ## JC48P6_1204_HSC_FE_S8_ Stem cells (SC.STSL) Upon summarizing the distribution of assigned labels, we see that many of them are related to stem cells, though there are quite a large number of more differentiated labels mixed in. This is probably because - despite what its name might suggest - the dataset obtained by GrunHSCData() actually contains more than HSCs. head(sort(table(pred$labels), decreasing=TRUE)) ## ## Stem cells (SC.MEP) Neutrophils (GN.ARTH) Macrophages (MF) ## 362 314 165 ## Stem cells (SC.STSL) B cells (proB.FrA) Stem cells (SC.LT34F) ## 142 121 103 If we restrict our analysis to the sorted HSCs (obviously) and remove one low-quality batch (see the analysis here for the rationale) we can see that the distribution of cell type labels is much more as expected. actual.hsc &lt;- pred$labels[sce$protocol==&quot;sorted hematopoietic stem cells&quot; &amp; sce$sample!=&quot;JC4&quot;] head(sort(table(actual.hsc), decreasing=TRUE)) ## actual.hsc ## Stem cells (SC.STSL) Stem cells (SC.LT34F) ## 109 98 ## Stem cells (SC.ST34F) Stem cells (SC.CD150-CD48-) ## 37 15 ## Stem cells (LTHSC) Stem cells (MLP) ## 12 8 2.3 Choices of assay data For the reference dataset, the assay matrix must contain log-transformed normalized expression values. This is because the default marker detection scheme computes log-fold changes by subtracting the medians, which makes little sense unless the input expression values are already log-transformed. For alternative schemes, this requirement may be relaxed (e.g., Wilcoxon rank sum tests do not require transformation); similarly, if pre-defined markers are supplied, no transformaton or normalization is necessary (see comments below for the test data). For the test data, the assay data need not be log-transformed or even (scale) normalized. This is because SingleR() computes Spearman correlations within each cell, which is unaffected by monotonic transformations like cell-specific scaling or log-transformation. It is perfectly satisfactory to provide the raw counts for the test dataset to SingleR(), which is the reason for setting assay.type.test=1 in our previous SingleR() call for the Grun dataset. The exception to this rule occurs when comparing data from full-length technologies to the built-in references. The built-in references are constructed to be comparable to unique molecular identifier (UMI) protocols, where the expression values are less sensitive to differences in gene length. Thus, when comparing Smart-seq2 test datasets to the built-in references, better performance can often be achieved by processing the test counts to transcripts-per-million values. We demonstrate below using another HSC dataset that was generated using the Smart-seq2 protocol (???). Again, we see that most of the predicted labels are related to stem cells, which is comforting. sce.nest &lt;- NestorowaHSCData() # Getting the exonic gene lengths. library(AnnotationHub) mm.db &lt;- AnnotationHub()[[&quot;AH73905&quot;]] mm.exons &lt;- exonsBy(mm.db, by=&quot;gene&quot;) mm.exons &lt;- reduce(mm.exons) mm.len &lt;- sum(width(mm.exons)) # Computing the TPMs with a simple scaling by gene length. library(scater) keep &lt;- intersect(names(mm.len), rownames(sce.nest)) tpm.nest &lt;- calculateTPM(sce.nest[keep,], lengths=mm.len[keep]) # Performing the assignment. pred &lt;- SingleR(test = tpm.nest, ref = immgen, labels = immgen$label.fine) head(sort(table(pred$labels), decreasing=TRUE), 10) ## ## Stem cells (SC.MEP) Stem cells (SC.ST34F) ## 409 357 ## Stem cells (SC.MPP34F) Stem cells (SC.CMP.DR) ## 329 298 ## Stem cells (MLP) Stem cells (GMP) ## 167 102 ## Stem cells (SC.STSL) Stem cells (SC.MDP) ## 71 66 ## Stem cells (SC.CD150-CD48-) Stem cells (SC.LT34F) ## 55 37 Session information sessionInfo() ## R version 4.0.0 Patched (2020-05-01 r78341) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 18.04.4 LTS ## ## Matrix products: default ## BLAS: /home/luna/Software/R/R-4-0-branch-dev/lib/libRblas.so ## LAPACK: /home/luna/Software/R/R-4-0-branch-dev/lib/libRlapack.so ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats4 parallel stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] AnnotationHub_2.21.0 BiocFileCache_1.13.0 ## [3] dbplyr_1.4.3 ensembldb_2.13.1 ## [5] AnnotationFilter_1.13.0 GenomicFeatures_1.41.0 ## [7] AnnotationDbi_1.51.0 knitr_1.28 ## [9] scater_1.17.0 ggplot2_3.3.0 ## [11] scRNAseq_2.3.0 SingleCellExperiment_1.11.1 ## [13] SingleR_1.3.2 SummarizedExperiment_1.19.2 ## [15] DelayedArray_0.15.1 matrixStats_0.56.0 ## [17] Biobase_2.49.0 GenomicRanges_1.41.1 ## [19] GenomeInfoDb_1.25.0 IRanges_2.23.4 ## [21] S4Vectors_0.27.5 BiocGenerics_0.35.2 ## [23] BiocStyle_2.17.0 ## ## loaded via a namespace (and not attached): ## [1] ProtGenerics_1.21.0 bitops_1.0-6 ## [3] bit64_0.9-7 progress_1.2.2 ## [5] httr_1.4.1 tools_4.0.0 ## [7] R6_2.4.1 irlba_2.3.3 ## [9] vipor_0.4.5 lazyeval_0.2.2 ## [11] DBI_1.1.0 colorspace_1.4-1 ## [13] withr_2.2.0 prettyunits_1.1.1 ## [15] tidyselect_1.0.0 gridExtra_2.3 ## [17] bit_1.1-15.2 curl_4.3 ## [19] compiler_4.0.0 BiocNeighbors_1.7.0 ## [21] rtracklayer_1.49.1 bookdown_0.18 ## [23] scales_1.1.0 askpass_1.1 ## [25] rappdirs_0.3.1 Rsamtools_2.5.0 ## [27] stringr_1.4.0 digest_0.6.25 ## [29] rmarkdown_2.1 XVector_0.29.0 ## [31] pkgconfig_2.0.3 htmltools_0.4.0 ## [33] fastmap_1.0.1 rlang_0.4.6 ## [35] RSQLite_2.2.0 shiny_1.4.0.2 ## [37] DelayedMatrixStats_1.11.0 BiocParallel_1.23.0 ## [39] dplyr_0.8.5 RCurl_1.98-1.2 ## [41] magrittr_1.5 BiocSingular_1.5.0 ## [43] GenomeInfoDbData_1.2.3 Matrix_1.2-18 ## [45] Rcpp_1.0.4.6 ggbeeswarm_0.6.0 ## [47] munsell_0.5.0 viridis_0.5.1 ## [49] lifecycle_0.2.0 stringi_1.4.6 ## [51] yaml_2.2.1 zlibbioc_1.35.0 ## [53] grid_4.0.0 blob_1.2.1 ## [55] promises_1.1.0 ExperimentHub_1.15.0 ## [57] crayon_1.3.4 lattice_0.20-41 ## [59] Biostrings_2.57.0 hms_0.5.3 ## [61] pillar_1.4.4 biomaRt_2.45.0 ## [63] codetools_0.2-16 XML_3.99-0.3 ## [65] glue_1.4.0 BiocVersion_3.12.0 ## [67] evaluate_0.14 BiocManager_1.30.10 ## [69] vctrs_0.2.4 httpuv_1.5.2 ## [71] openssl_1.4.1 gtable_0.3.0 ## [73] purrr_0.3.4 assertthat_0.2.1 ## [75] xfun_0.13 rsvd_1.0.3 ## [77] mime_0.9 xtable_1.8-4 ## [79] later_1.0.0 viridisLite_0.3.0 ## [81] tibble_3.0.1 GenomicAlignments_1.25.0 ## [83] beeswarm_0.2.3 memoise_1.1.0 ## [85] ellipsis_0.3.0 interactiveDisplayBase_1.27.0 Bibliography "],
["using-single-cell-references.html", "Chapter 3 Using single-cell references 3.1 Overview 3.2 Annotation with test-based marker detection 3.3 Defining custom markers 3.4 Pseudo-bulk aggregation Session information", " Chapter 3 Using single-cell references 3.1 Overview Another application of SingleR involves using one single-cell dataset as a reference to annotate others. This is almost identical to the use of the built-in bulk references described in Chapter 2, with the main difference involving the marker detection strategy that is applied to the reference labels. In particular, we identify top-ranked markers based on pairwise Wilcoxon rank sum tests or \\(t\\)-tests between labels; this allows us to account for the variability across cells to choose genes that are robustly upregulated in each label. Despite the name of this chapter, the functionality described here is not limited to single-cell references. The determining factor is whether a dataset contains enough samples for each label to permit the use of statistical tests for marker detection. This scenario is most common for single-cell references but the same approach can be applied to bulk references with many replicate samples. 3.2 Annotation with test-based marker detection Here, we will use two human pancreas scRNA-seq datasets from the scRNAseq package. The aim is to use one pre-labelled dataset to annotate the other unlabelled dataset. First, we set up the Muraro et al. (2016) dataset to be our reference, computing log-normalized expression values as discussed in Section 2.3. library(scRNAseq) sceM &lt;- MuraroPancreasData() # Removing unlabelled cells or cells without a clear label. sceM &lt;- sceM[,!is.na(sceM$label) &amp; sceM$label!=&quot;unclear&quot;] library(scater) sceM &lt;- logNormCounts(sceM) sceM ## class: SingleCellExperiment ## dim: 19059 2122 ## metadata(0): ## assays(2): counts logcounts ## rownames(19059): A1BG-AS1__chr19 A1BG__chr19 ... ZZEF1__chr17 ## ZZZ3__chr1 ## rowData names(2): symbol chr ## colnames(2122): D28-1_1 D28-1_2 ... D30-8_93 D30-8_94 ## colData names(4): label donor plate sizeFactor ## reducedDimNames(0): ## altExpNames(1): ERCC # Seeing the available labels in this dataset. table(sceM$label) ## ## acinar alpha beta delta duct endothelial ## 219 812 448 193 245 21 ## epsilon mesenchymal pp ## 3 80 101 We then set up our test dataset from Grun et al. (2016), applying some basic quality control as discusssed here. (As SingleR() operates independently on each cell, quality control on the test dataset can actually be applied after annotation is performed. We only apply it beforehand here to simplify the interpretation of the downstream results.) We also compute the log-transformed values here, not because it is strictly necessary but so that we don’t have to keep on typing assay.type.test=1 in later calls to SingleR(). sceG &lt;- GrunPancreasData() sceG &lt;- addPerCellQC(sceG) qc &lt;- quickPerCellQC(colData(sceG), percent_subsets=&quot;altexps_ERCC_percent&quot;, batch=sceG$donor, subset=sceG$donor %in% c(&quot;D17&quot;, &quot;D7&quot;, &quot;D2&quot;)) sceG &lt;- sceG[,!qc$discard] sceG &lt;- logNormCounts(sceG) sceG ## class: SingleCellExperiment ## dim: 20064 1064 ## metadata(0): ## assays(2): counts logcounts ## rownames(20064): A1BG-AS1__chr19 A1BG__chr19 ... ZZEF1__chr17 ## ZZZ3__chr1 ## rowData names(2): symbol chr ## colnames(1064): D2ex_1 D2ex_2 ... D17TGFB_94 D17TGFB_95 ## colData names(13): donor sample ... total sizeFactor ## reducedDimNames(0): ## altExpNames(1): ERCC We run SingleR() as described previously but with a marker detection mode that considers the variance of expression across cells. Here, we will use the Wilcoxon ranked sum test to identify the top markers for each pairwise comparison between labels. This is slower but more appropriate for single-cell data compared to the default marker detection algorithm, which may fail for low-coverage data where the median for each label is often zero. library(SingleR) pred.grun &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, de.method=&quot;wilcox&quot;) table(pred.grun$labels) ## ## acinar beta delta duct ## 53 4 2 41 By default, the function will take the top de.n (default: 10) genes from each pairwise comparison between labels. A larger number of markers increases the robustness of the annotation by ensuring that relevant genes are not omitted, especially if the reference dataset has study-specific effects that cause uninteresting genes to dominate the top set. However, this comes at the cost of increasing noise and computational time. library(SingleR) pred.grun &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, de.method=&quot;wilcox&quot;, de.n=50) table(pred.grun$labels) ## ## acinar alpha beta delta duct endothelial ## 275 203 177 55 307 5 ## epsilon mesenchymal pp ## 1 23 18 3.3 Defining custom markers The marker detection in SingleR() is built on top of the testing framework in scran, so most options in ?pairwiseWilcox and friends can be applied via the de.args= option. For example, we could use the \\(t\\)-test and test against a log-fold change threshold with de.args=list(lfc=1). library(SingleR) pred.grun2 &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, de.method=&quot;t&quot;, de.args=list(lfc=1)) table(pred.grun2$labels) ## ## acinar alpha beta delta duct endothelial ## 285 200 177 54 296 5 ## epsilon mesenchymal pp ## 5 24 18 However, users can also construct their own marker lists with any DE testing machinery. For example, we can perform pairwise binomial tests to identify genes that are differentially detected (i.e., have differences in the proportion of cells with non-zero counts) between labels in the reference Muraro dataset. We then take the top 10 marker genes from each pairwise comparison, obtaining a list of lists of character vectors containing the identities of the markers for that comparison. library(scran) out &lt;- pairwiseBinom(counts(sceM), sceM$label, direction=&quot;up&quot;) markers &lt;- getTopMarkers(out$statistics, out$pairs, n=10) # Upregulated in acinar compared to alpha: markers$acinar$alpha ## [1] &quot;KCNQ1__chr11&quot; &quot;FAM129A__chr1&quot; &quot;KLK1__chr19&quot; &quot;NTN4__chr12&quot; ## [5] &quot;RASEF__chr9&quot; &quot;CTRL__chr16&quot; &quot;LGALS2__chr22&quot; &quot;NUPR1__chr16&quot; ## [9] &quot;LGALS3__chr14&quot; &quot;NR5A2__chr1&quot; # Upregulated in alpha compared to acinar: markers$alpha$acinar ## [1] &quot;SLC38A4__chr12&quot; &quot;ARX__chrX&quot; &quot;CRYBA2__chr2&quot; &quot;FSTL5__chr4&quot; ## [5] &quot;GNG2__chr14&quot; &quot;NOL4__chr18&quot; &quot;IRX2__chr5&quot; &quot;KCNMB2__chr3&quot; ## [9] &quot;CFC1__chr2&quot; &quot;KCNJ6__chr21&quot; Once we have this list of lists, we supply it to SingleR() via the genes= argument, which causes the function to bypass the internal marker detection to use the supplied gene sets instead. The most obvious benefit of this approach is that the user can achieve greater control of the markers, allowing integration of prior biological knowledge to obtain more relevant genes and a more robust annotation. pred.grun2b &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, genes=markers) table(pred.grun2b$labels) ## ## acinar alpha beta delta duct endothelial ## 276 202 175 54 302 5 ## epsilon mesenchymal pp ## 2 25 23 In some cases, markers may only be available for specific labels rather than for pairwise comparisons between labels. This is accommodated by supplying a named list of character vectors to genes. Note that this is likely to be less powerful than the list-of-lists approach as information about pairwise differences is discarded. # Creating label-specific markers. label.markers &lt;- lapply(markers, unlist) label.markers &lt;- lapply(label.markers, unique) str(label.markers) ## List of 9 ## $ acinar : chr [1:40] &quot;KCNQ1__chr11&quot; &quot;FAM129A__chr1&quot; &quot;KLK1__chr19&quot; &quot;NTN4__chr12&quot; ... ## $ alpha : chr [1:41] &quot;SLC38A4__chr12&quot; &quot;ARX__chrX&quot; &quot;CRYBA2__chr2&quot; &quot;FSTL5__chr4&quot; ... ## $ beta : chr [1:47] &quot;ELAVL4__chr1&quot; &quot;PRUNE2__chr9&quot; &quot;NMNAT2__chr1&quot; &quot;PLCB4__chr20&quot; ... ## $ delta : chr [1:44] &quot;NOL4__chr18&quot; &quot;CABP7__chr22&quot; &quot;UNC80__chr2&quot; &quot;HEPACAM2__chr7&quot; ... ## $ duct : chr [1:50] &quot;ADCY5__chr3&quot; &quot;PDE3A__chr12&quot; &quot;SLC3A1__chr2&quot; &quot;BICC1__chr10&quot; ... ## $ endothelial: chr [1:26] &quot;GPR4__chr19&quot; &quot;TMEM204__chr16&quot; &quot;GPR116__chr6&quot; &quot;CYYR1__chr21&quot; ... ## $ epsilon : chr [1:14] &quot;BHMT__chr5&quot; &quot;JPH3__chr16&quot; &quot;SERPINA10__chr14&quot; &quot;UGT2B4__chr4&quot; ... ## $ mesenchymal: chr [1:34] &quot;TNFAIP6__chr2&quot; &quot;THBS2__chr6&quot; &quot;CDH11__chr16&quot; &quot;SRPX2__chrX&quot; ... ## $ pp : chr [1:44] &quot;SERTM1__chr13&quot; &quot;ETV1__chr7&quot; &quot;ARX__chrX&quot; &quot;ELAVL4__chr1&quot; ... pred.grun2c &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, genes=label.markers) table(pred.grun2c$labels) ## ## acinar alpha beta delta duct endothelial ## 262 204 169 59 317 6 ## epsilon mesenchymal pp ## 2 24 21 3.4 Pseudo-bulk aggregation Single-cell reference datasets provide a like-for-like comparison to our test single-cell datasets, yielding a more accurate classification of the cells in the latter (hopefully). However, there are frequently many more samples in single-cell references compared to bulk references, increasing the computational work involved in classification. We avoid this by aggregating cells into one “pseudo-bulk” sample per label (e.g., by averaging across log-expression values) and using those as the reference, which allows us to achieve the same efficiency as the use of bulk references. The obvious cost of this approach is that we discard potentially useful information about the distribution of cells within each label. Cells that belong to a heterogeneous population may not be correctly assigned if they are far from the population center. We attempt to preserve some of this information by using \\(k\\)-means clustering within each cell to create pseudo-bulk samples that are representative of a particular region of the expression space (i.e., vector quantization). We create \\(\\sqrt{N}\\) clusters given a label with \\(N\\) cells, which provides a reasonable compromise between reducing computational work and preserving the label’s internal distribution. To enable this aggregation, we simply set aggr.ref=TRUE in the SingleR() call. This uses the aggregateReference() function to perform \\(k\\)-means clustering within each label (typically after principal components analysis on the log-expression matrix, for greater speed) and average expression values for each within-label cluster. Note that marker detection is still performed on the unaggregated data so as to make full use of the distribution of expression values across cells. set.seed(100) # for the k-means step. pred.grun3 &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, de.method=&quot;wilcox&quot;, aggr.ref=TRUE) table(pred.grun3$labels) ## ## acinar alpha beta delta duct endothelial ## 277 202 184 47 306 5 ## epsilon mesenchymal pp ## 1 22 20 Obviously, the aggregation itself requires computational work so setting aggr.ref=TRUE in SingleR() itself may not improve speed. Rather, the real power of this approach lies in pre-aggregating the reference dataset so that it can be repeatedly applied to quickly annotate multiple test datasets. This approach is discussed in more detail in Chapter 7. Session information sessionInfo() ## R version 4.0.0 Patched (2020-05-01 r78341) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 18.04.4 LTS ## ## Matrix products: default ## BLAS: /home/luna/Software/R/R-4-0-branch-dev/lib/libRblas.so ## LAPACK: /home/luna/Software/R/R-4-0-branch-dev/lib/libRlapack.so ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats4 parallel stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] scran_1.17.0 SingleR_1.3.2 ## [3] scater_1.17.0 ggplot2_3.3.0 ## [5] scRNAseq_2.3.0 SingleCellExperiment_1.11.1 ## [7] SummarizedExperiment_1.19.2 DelayedArray_0.15.1 ## [9] matrixStats_0.56.0 Biobase_2.49.0 ## [11] GenomicRanges_1.41.1 GenomeInfoDb_1.25.0 ## [13] IRanges_2.23.4 S4Vectors_0.27.5 ## [15] BiocGenerics_0.35.2 BiocStyle_2.17.0 ## ## loaded via a namespace (and not attached): ## [1] bitops_1.0-6 bit64_0.9-7 ## [3] httr_1.4.1 tools_4.0.0 ## [5] R6_2.4.1 irlba_2.3.3 ## [7] vipor_0.4.5 DBI_1.1.0 ## [9] colorspace_1.4-1 withr_2.2.0 ## [11] tidyselect_1.0.0 gridExtra_2.3 ## [13] bit_1.1-15.2 curl_4.3 ## [15] compiler_4.0.0 BiocNeighbors_1.7.0 ## [17] bookdown_0.18 scales_1.1.0 ## [19] rappdirs_0.3.1 stringr_1.4.0 ## [21] digest_0.6.25 rmarkdown_2.1 ## [23] XVector_0.29.0 pkgconfig_2.0.3 ## [25] htmltools_0.4.0 limma_3.45.0 ## [27] dbplyr_1.4.3 fastmap_1.0.1 ## [29] rlang_0.4.6 RSQLite_2.2.0 ## [31] shiny_1.4.0.2 DelayedMatrixStats_1.11.0 ## [33] BiocParallel_1.23.0 dplyr_0.8.5 ## [35] RCurl_1.98-1.2 magrittr_1.5 ## [37] BiocSingular_1.5.0 scuttle_0.99.5 ## [39] GenomeInfoDbData_1.2.3 Matrix_1.2-18 ## [41] Rcpp_1.0.4.6 ggbeeswarm_0.6.0 ## [43] munsell_0.5.0 viridis_0.5.1 ## [45] lifecycle_0.2.0 stringi_1.4.6 ## [47] yaml_2.2.1 edgeR_3.31.0 ## [49] zlibbioc_1.35.0 BiocFileCache_1.13.0 ## [51] AnnotationHub_2.21.0 grid_4.0.0 ## [53] blob_1.2.1 promises_1.1.0 ## [55] dqrng_0.2.1 ExperimentHub_1.15.0 ## [57] crayon_1.3.4 lattice_0.20-41 ## [59] locfit_1.5-9.4 knitr_1.28 ## [61] pillar_1.4.4 igraph_1.2.5 ## [63] codetools_0.2-16 glue_1.4.0 ## [65] BiocVersion_3.12.0 evaluate_0.14 ## [67] BiocManager_1.30.10 vctrs_0.2.4 ## [69] httpuv_1.5.2 gtable_0.3.0 ## [71] purrr_0.3.4 assertthat_0.2.1 ## [73] xfun_0.13 rsvd_1.0.3 ## [75] mime_0.9 xtable_1.8-4 ## [77] later_1.0.0 viridisLite_0.3.0 ## [79] tibble_3.0.1 AnnotationDbi_1.51.0 ## [81] beeswarm_0.2.3 memoise_1.1.0 ## [83] statmod_1.4.34 ellipsis_0.3.0 ## [85] interactiveDisplayBase_1.27.0 Bibliography "],
["annotation-diagnostics.html", "Chapter 4 Annotation diagnostics 4.1 Based on the scores within cells 4.2 Based on the deltas across cells 4.3 Based on marker gene expression", " Chapter 4 Annotation diagnostics 4.1 Based on the scores within cells SingleR provides a few basic yet powerful visualization tools. plotScoreHeatmap() displays the scores for all cells across all reference labels, which allows users to inspect the confidence of the predicted labels across the dataset. The actual assigned label for each cell is shown in the color bar at the top; note that this may not be the visually top-scoring label if fine-tuning is applied, as the only the pre-tuned scores are directly comparable across all labels. library(SingleR) plotScoreHeatmap(pred.grun) For this plot, the key point is to examine the spread of scores within each cell. Ideally, each cell (i.e., column of the heatmap) should have one score that is obviously larger than the rest, indicating that it is unambiguously assigned to a single label. A spread of similar scores for a given cell indicates that the assignment is uncertain, though this may be acceptable if the uncertainty is distributed across similar cell types that cannot be easily resolved. We can also display other metadata information for each cell by setting clusters= or annotation_col=. This is occasionally useful for examining potential batch effects, differences in cell type composition between conditions, relationship to clusters from an unsupervised analysis, etc. In the code below, we display which donor each cell comes from: plotScoreHeatmap(pred.grun, annotation_col=as.data.frame(colData(sceG)[,&quot;donor&quot;,drop=FALSE])) 4.2 Based on the deltas across cells The pruneScores() function will remove potentially poor-quality or ambiguous assignments. In particular, ambiguous assignments are identified based on the per-cell “delta”, i.e., the difference between the score for the assigned label and the median across all labels for each cell. Low deltas indicate that the assignment is uncertain, which is especially relevant if the cell’s true label does not exist in the reference. The exact threshold used for pruning is identified using an outlier-based approach that accounts for differences in the scale of the correlations in various contexts. to.remove &lt;- pruneScores(pred.grun) summary(to.remove) ## Mode FALSE TRUE ## logical 96 4 By default, SingleR() will report pruned labels in the pruned.labels field where low-quality assignments are replaced with NA. However, the default pruning thresholds may not be appropriate for every dataset - see ?pruneScores for a more detailed discussion. We provide the plotScoreDistribution() to help in determining whether the thresholds are appropriate by using information across cells with the same label. This displays the per-label distribution of the deltas across cells, from which pruneScores() defines an appropriate threshold as 3 median absolute deviations (MADs) below the median. plotScoreDistribution(pred.grun, show = &quot;delta.med&quot;, ncol = 3, show.nmads = 3) If some tuning parameters must be adjusted, we can simply call pruneScores() directly with adjusted parameters. Here, we set labels to NA if they are to be discarded, which is also how SingleR() marks such labels in pruned.labels. new.pruned &lt;- pred.grun$labels new.pruned[pruneScores(pred.grun, nmads=5)] &lt;- NA table(new.pruned, useNA=&quot;always&quot;) ## new.pruned ## acinar beta delta duct &lt;NA&gt; ## 53 4 2 41 0 4.3 Based on marker gene expression Another simple yet effective diagnostic is to examine the expression of the marker genes for each label in the test dataset. We extract the identity of the markers from the metadata of the SingleR() results and use them in the plotHeatmap() function from scater, as shown below for beta cell markers. If a cell in the test dataset is confidently assigned to a particular label, we would expect it to have strong expression of that label’s markers. At the very least, it should exhibit upregulation of those markers relative to cells assigned to other labels. all.markers &lt;- metadata(pred.grun)$de.genes sceG$labels &lt;- pred.grun$labels # Beta cell-related markers library(scater) plotHeatmap(sceG, order_columns_by=&quot;labels&quot;, features=unique(unlist(all.markers$beta))) We can similarly perform this for all labels by wrapping this code in a loop, as shown below: for (lab in unique(pred.grun$labels)) { plotHeatmap(sceG, order_columns_by=list(I(pred.grun$labels)), features=unique(unlist(all.markers[[lab]]))) } Heatmaps are particularly useful because they allow users to check that the genes are actually biologically meaningful to that cell type’s identity. For example, beta cells would be expected to express insulin, and the fact that they do so gives more confidence to the correctness of the assignment. By comparison, the scores and deltas are more abstract and difficult to interpret for diagnostic purposes. If the identified markers are not meaningful or not consistently upregulated, some skepticism towards the quality of the assignments is warranted. "],
["using-multiple-references.html", "Chapter 5 Using multiple references", " Chapter 5 Using multiple references In some cases, we may wish to use multiple references for annotation of a test dataset. This yield a more comprehensive set of cell types that are not covered by any individual reference, especially when differences in resolution are also considered. Use of multiple references is supported by simply passing multiple objects to the ref= and label= argument in SingleR(). We demonstrate below by including another reference (from Blueprint-Encode) in our annotation of the La Manno et al. (2016) dataset: library(scRNAseq) hESCs &lt;- LaMannoBrainData(&#39;human-es&#39;) library(scater) hESCs &lt;- logNormCounts(hESCs) library(SingleR) bp.se &lt;- BlueprintEncodeData() hpca.se &lt;- HumanPrimaryCellAtlasData() pred.combined &lt;- SingleR(test = hESCs, ref = list(BP=bp.se, HPCA=hpca.se), labels = list(bp.se$label.main, hpca.se$label.main)) The output is the same form as previously described, and we can easily gain access to the combined set of labels: table(pred.combined$labels) ## ## Astrocyte Astrocytes Chondrocytes ## 22 2 1 ## Embryonic_stem_cells Erythrocytes HSC ## 128 1 1 ## iPS_cells Mesangial cells Neuroepithelial_cell ## 193 1 1016 ## Neurons Smooth_muscle_cells Tissue_stem_cells ## 342 7 1 Our strategy is to perform annotation on each reference separately and then take the highest-scoring label across references. This provides a light-weight approach to combining information from multiple references while avoiding batch effects and the need for up-front harmonization. (Of course, the main practical difficulty of this approach is that the same cell type may have different labels across references, which will require some implicit harmonization during interpretation.) Further comments on the justification behind the choice of this method can be found at ?&quot;combine-predictions&quot;. Bibliography "],
["harmonizing-labels.html", "Chapter 6 Harmonizing labels", " Chapter 6 Harmonizing labels The matchReferences() function provides a simple yet elegant approach for label harmonization between two references. Each reference is used to annotate the other and the probability of mutual assignment between each pair of labels is computed. Probabilities close to 1 indicate there is a 1:1 relation between that pair of labels; on the other hand, an all-zero probability vector indicates that a label is unique to a particular reference. library(SingleR) bp.se &lt;- BlueprintEncodeData() hpca.se &lt;- HumanPrimaryCellAtlasData() matched &lt;- matchReferences(bp.se, hpca.se, bp.se$label.main, hpca.se$label.main) pheatmap::pheatmap(matched, col=viridis::plasma(100)) A heatmap like the one above can be used to guide harmonization to enforce a consistent vocabulary across all labels representing the same cell type or state. The most obvious benefit of harmonization is that interpretation of the results is simplified. However, an even more important effect is that the presence of harmonized labels from multiple references allows the classification machinery to protect against irrelevant batch effects between references. For example, in SingleR()’s case, marker genes are favored if they are consistently upregulated across multiple references, improving robustness to technical idiosyncrasies in any test dataset. We stress that some manual intervention is still required in this process, given the risks posed by differences in biological systems and technologies. For example, neurons are considered unique to each reference while smooth muscle cells in the HPCA data are incorrectly matched to fibroblasts in the Blueprint/ENCODE data. CD4+ and CD8+ T cells are also both assigned to “T cells”, so some decision about the acceptable resolution of the harmonized labels is required here. As an aside, we can also use this function to identify the matching clusters between two independent scRNA-seq analyses. This is an “off-label” use that involves substituting the cluster assignments as proxies for the labels. We can then match up clusters and integrate conclusions from multiple datasets without the difficulty of batch correction and reclustering. "],
["advanced-options.html", "Chapter 7 Advanced options 7.1 Preconstructed indices 7.2 Parallelization 7.3 Approximate algorithms Session information", " Chapter 7 Advanced options 7.1 Preconstructed indices Advanced users can split the SingleR() workflow into two separate training and classification steps. This means that training (e.g., marker detection, assembling of nearest-neighbor indices) only needs to be performed once. The resulting data structures can then be re-used across multiple classifications with different test datasets, provided the gene annotation in the test dataset is identical to or a superset of the genes in the training set. To illustrate, we will consider the DICE reference dataset (Schmiedel et al. 2018). library(SingleR) dice &lt;- DatabaseImmuneCellExpressionData(ensembl=TRUE) dice ## class: SummarizedExperiment ## dim: 29914 1561 ## metadata(0): ## assays(1): logcounts ## rownames(29914): ENSG00000121410 ENSG00000268895 ... ENSG00000159840 ## ENSG00000074755 ## rowData names(0): ## colnames(1561): TPM_1 TPM_2 ... TPM_101 TPM_102 ## colData names(3): label.main label.fine label.ont table(dice$label.fine) ## ## B cells, naive Monocytes, CD14+ ## 106 106 ## Monocytes, CD16+ NK cells ## 105 105 ## T cells, CD4+, memory TREG T cells, CD4+, naive ## 104 103 ## T cells, CD4+, naive TREG T cells, CD4+, naive, stimulated ## 104 102 ## T cells, CD4+, TFH T cells, CD4+, Th1 ## 104 104 ## T cells, CD4+, Th1_17 T cells, CD4+, Th17 ## 104 104 ## T cells, CD4+, Th2 T cells, CD8+, naive ## 104 104 ## T cells, CD8+, naive, stimulated ## 102 Let’s say we want to use the DICE reference to annotate the PBMC dataset from Chapter 1. library(TENxPBMCData) sce &lt;- TENxPBMCData(&quot;pbmc3k&quot;) We use the trainSingleR() function to do all the necessary calculations that are independent of the test dataset. (Well, almost; see comments below about common.) This yields a list of various components that contains all identified marker genes and precomputed rank indices to be used in the score calculation. common &lt;- intersect(rownames(sce), rownames(dice)) trained &lt;- trainSingleR(dice[common,], labels=dice$label.fine) It is then a simple matter to use the trained object to annotate our dataset of interest through the classifySingleR() function. As we can see, this yields exactly the same result as applying SingleR() directly; however, the advantage here is that trained can be re-used for multiple classifySingleR() calls - possibly on different datasets - without having to repeat unnecessary steps when the reference is unchanged. pred &lt;- classifySingleR(sce, trained, assay.type=1) table(pred$labels) ## ## B cells, naive Monocytes, CD14+ ## 344 516 ## Monocytes, CD16+ NK cells ## 186 320 ## T cells, CD4+, memory TREG T cells, CD4+, naive ## 148 111 ## T cells, CD4+, naive TREG T cells, CD4+, TFH ## 28 461 ## T cells, CD4+, Th1 T cells, CD4+, Th1_17 ## 213 61 ## T cells, CD4+, Th17 T cells, CD4+, Th2 ## 57 41 ## T cells, CD8+, naive ## 214 # Comparing to the direct approach. direct &lt;- SingleR(sce, ref=dice, assay.type.test=1, labels=dice$label.fine) identical(pred$labels, direct$labels) ## [1] TRUE The big caveat is that the universe of genes in the test dataset cannot be greater than that in the reference. This is the reason behind the intersection to common genes and the subsequent subsetting of dice. Practical use of preconstructed indices is best combined with some prior information about the gene-level annotation; for example, we might know that we always use a particular version of the Ensembl gene models, so we would filter out any genes in the reference dataset that are not in the Ensembl annotation. 7.2 Parallelization Parallelization is an obvious approach to increasing annotation throughput. This is done using the framework in the BiocParallel package, which provides several options for parallelization depending on the available hardware. On POSIX-compliant systems (i.e., Linux and MacOS), the simplest method is to use forking by passing MulticoreParam() to the BPPARAM= argument: library(BiocParallel) pred2a &lt;- SingleR(sce, ref=dice, assay.type.test=1, labels=dice$label.fine, BPPARAM=MulticoreParam(8)) # 8 CPUs. identical(pred$labels, pred2a$labels) ## [1] TRUE Alternatively, one can use separate processes with SnowParam(), which is slower but can be used on all systems including Windows. pred2b &lt;- SingleR(sce, ref=dice, assay.type.test=1, labels=dice$label.fine, BPPARAM=SnowParam(8)) identical(pred$labels, pred2b$labels) ## [1] TRUE When working on a cluster, the BatchtoolsParam() function allows SingleR() to seamlessly interface with various job schedulers like SLURM, LSF and so on. This permits heavy-duty parallelization across hundreds of CPUs for highly intensive jobs, though often some configuration is required - see the vignette for more details. 7.3 Approximate algorithms It is possible to sacrifice accuracy to squeeze more speed out of SingleR. The most obvious approach is to simply turn off the fine-tuning with fine.tune=FALSE, which avoids the time-consuming fine-tuning iterations. When the reference labels are well-separated, this is probably an acceptable trade-off. pred3a &lt;- SingleR(sce, ref=dice, assay.type.test=1, labels=dice$label.main, fine.tune=FALSE) table(pred3a$labels) ## ## B cells Monocytes NK cells T cells, CD4+ T cells, CD8+ ## 348 705 357 950 340 Another approximation is based on the fact that the score calculation is done using a nearest-neighbors search. By default, this is an exact seach but we can switch to an approximate algorithm via the BNPARAM= argument. In the example below, we use the Annoy algorithm via the BiocNeighbors framework, which yields mostly similar results. (Note, though, that the Annoy method does involve a considerable amount of overhead, so for small jobs it will actually be slower than the exact search.) library(BiocNeighbors) pred3b &lt;- SingleR(sce, ref=dice, assay.type.test=1, labels=dice$label.main, BNPARAM=AnnoyParam()) table(pred3a$labels, pred3b$labels) ## ## B cells Monocytes NK cells T cells, CD4+ T cells, CD8+ ## B cells 347 1 0 0 0 ## Monocytes 0 705 0 0 0 ## NK cells 0 0 341 11 5 ## T cells, CD4+ 0 0 4 900 46 ## T cells, CD8+ 0 0 2 59 279 Session information sessionInfo() ## R version 4.0.0 Patched (2020-05-01 r78341) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 18.04.4 LTS ## ## Matrix products: default ## BLAS: /home/luna/Software/R/R-4-0-branch-dev/lib/libRblas.so ## LAPACK: /home/luna/Software/R/R-4-0-branch-dev/lib/libRlapack.so ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats4 parallel stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] BiocNeighbors_1.7.0 BiocParallel_1.23.0 ## [3] TENxPBMCData_1.7.0 HDF5Array_1.17.0 ## [5] rhdf5_2.33.0 ensembldb_2.13.1 ## [7] AnnotationFilter_1.13.0 GenomicFeatures_1.41.0 ## [9] AnnotationDbi_1.51.0 SingleR_1.3.2 ## [11] scater_1.17.0 ggplot2_3.3.0 ## [13] scRNAseq_2.3.0 SingleCellExperiment_1.11.1 ## [15] SummarizedExperiment_1.19.2 DelayedArray_0.15.1 ## [17] matrixStats_0.56.0 Biobase_2.49.0 ## [19] GenomicRanges_1.41.1 GenomeInfoDb_1.25.0 ## [21] IRanges_2.23.4 S4Vectors_0.27.5 ## [23] BiocGenerics_0.35.2 BiocStyle_2.17.0 ## ## loaded via a namespace (and not attached): ## [1] ggbeeswarm_0.6.0 colorspace_1.4-1 ## [3] ellipsis_0.3.0 XVector_0.29.0 ## [5] bit64_0.9-7 interactiveDisplayBase_1.27.0 ## [7] codetools_0.2-16 knitr_1.28 ## [9] Rsamtools_2.5.0 dbplyr_1.4.3 ## [11] shiny_1.4.0.2 BiocManager_1.30.10 ## [13] compiler_4.0.0 httr_1.4.1 ## [15] assertthat_0.2.1 Matrix_1.2-18 ## [17] fastmap_1.0.1 lazyeval_0.2.2 ## [19] later_1.0.0 BiocSingular_1.5.0 ## [21] htmltools_0.4.0 prettyunits_1.1.1 ## [23] tools_4.0.0 rsvd_1.0.3 ## [25] gtable_0.3.0 glue_1.4.0 ## [27] GenomeInfoDbData_1.2.3 dplyr_0.8.5 ## [29] rappdirs_0.3.1 Rcpp_1.0.4.6 ## [31] vctrs_0.2.4 Biostrings_2.57.0 ## [33] ExperimentHub_1.15.0 rtracklayer_1.49.1 ## [35] DelayedMatrixStats_1.11.0 xfun_0.13 ## [37] stringr_1.4.0 mime_0.9 ## [39] lifecycle_0.2.0 irlba_2.3.3 ## [41] XML_3.99-0.3 AnnotationHub_2.21.0 ## [43] zlibbioc_1.35.0 scales_1.1.0 ## [45] hms_0.5.3 promises_1.1.0 ## [47] ProtGenerics_1.21.0 yaml_2.2.1 ## [49] curl_4.3 memoise_1.1.0 ## [51] gridExtra_2.3 biomaRt_2.45.0 ## [53] stringi_1.4.6 RSQLite_2.2.0 ## [55] BiocVersion_3.12.0 rlang_0.4.6 ## [57] pkgconfig_2.0.3 bitops_1.0-6 ## [59] evaluate_0.14 lattice_0.20-41 ## [61] purrr_0.3.4 Rhdf5lib_1.11.0 ## [63] GenomicAlignments_1.25.0 bit_1.1-15.2 ## [65] tidyselect_1.0.0 magrittr_1.5 ## [67] bookdown_0.18 R6_2.4.1 ## [69] snow_0.4-3 DBI_1.1.0 ## [71] pillar_1.4.4 withr_2.2.0 ## [73] RCurl_1.98-1.2 tibble_3.0.1 ## [75] crayon_1.3.4 BiocFileCache_1.13.0 ## [77] rmarkdown_2.1 viridis_0.5.1 ## [79] progress_1.2.2 grid_4.0.0 ## [81] blob_1.2.1 digest_0.6.25 ## [83] xtable_1.8-4 httpuv_1.5.2 ## [85] openssl_1.4.1 munsell_0.5.0 ## [87] beeswarm_0.2.3 viridisLite_0.3.0 ## [89] vipor_0.4.5 askpass_1.1 Bibliography "],
["contributors.html", "Chapter 8 Contributors", " Chapter 8 Contributors Aaron Lun An ancient interdimensional horror who has recently awoken from his aeons-long slumber. His true name cannot be pronounced by the human tongue and his true form cannot be grasped by the human mind. It is said that, when the stars are right, he will herald the return of the Old Ones to plunge the world into darkness once more. In the meantime, he maintains about 20 Bioconductor packages for analyzing a range of genomics data modalities. "],
["bibliography.html", "Chapter 9 Bibliography", " Chapter 9 Bibliography "]
]
