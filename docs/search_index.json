[
["index.html", "Assigning cell types with SingleR Preface", " Assigning cell types with SingleR 2020-05-24 Preface Imagine a world without a reference genome. Whenever you receive new sequencing data - and we’ll just talk about transcriptomic data for now - you’ll have to run it through an assembler to characterize the genes that are being expressed. If you’re lucky enough to get a decent assembly that isn’t confused by contamination or homologous sequences, it falls on you to pick through the sequence motifs to figure out what what the gene actually is. And if you’re at a conference and you hear the name of a gene you’re working on, how can you be sure that everyone’s talking about the same thing? Now, this particular scenario only exists history books but it’s easy to see the parallels with single-cell data analyses; simply replace reads with cells, assemblies with clusters, and genes with cell types. In the single-cell analysis field, a typical practitioner will hope that their clusters are reasonable proxies for the biological states of interest (a strong assumption indeed!) and that their manual annotation of the clusters is accurate (which is itself dependent on domain expertise and coffee consumption). The current process of clustering, looking at a handful of markers and making a guesstimate of the cell type is best described as “artisanal” - which is not inherently bad, but one would hope that a mature technology would not require so much manual intervention for its routine use. If hard work is a disease, then automation is the cure, and this case is no exception. Automated cell type annotation methods match cells in a new dataset against curated reference profiles of known cell types, assigning each cell to the type that its expression profile is most similar to. This allows users to skip the mundane annotation of their data and jump directly to the interesting questions - does my cell type change in abundance or expression across treatments? Is there interesting substructure within an existing population? In this respect, automated annotation methods are the single-cell field’s equivalent to genome aligners, and one hopes that the former will become standard procedure for single-cell data analysis. This book covers the use of SingleR, one implementation of an automated annotation method. If you want a survey of different annotation methods - this book is not for you. If you want to create hand-crafted cluster definitions - this book is not for you. (Read the other one instead.) If you want to use the pre-Bioconductor version of the package - this book is not for you. But if you’re tired of manually annotating your single-cell data and you want to do something better with your life, then read on. "],
["introduction.html", "Chapter 1 Introduction 1.1 Motivation 1.2 Method description 1.3 Quick start 1.4 Where to get help Session information", " Chapter 1 Introduction .aaron-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .aaron-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 1.1 Motivation The Bioconductor package SingleR implements an automatic annotation method for single-cell RNA sequencing (scRNA-seq) data (Aran et al. 2019). Given a reference dataset of samples (single-cell or bulk) with known labels, it assigns those labels to new cells from a test dataset based on similarities in their expression profiles. This provides a convenient way of transferring biological knowledge across datasets, allowing users to leverage the domain expertise implicit in the creation of each reference. The most common application of SingleR involves predicting cell type (or “state”, or “kind”) in a new dataset, a process that is facilitated by the availability of built-in references and compatibility with user-supplied datasets. In this manner, the burden of manually interpreting clusters and defining marker genes only has to be done once, for the reference dataset, and this knowledge can be propagated to new datasets in an automated manner. 1.2 Method description SingleR can be considered a robust variant of nearest-neighbors classification, with some tweaks to improve resolution for closely related labels. For each test cell: We compute the Spearman correlation between its expression profile and that of each reference sample. The use of Spearman’s correlation provides a measure of robustness to batch effects across datasets. The calculation only uses the union of marker genes identified by pairwise comparisons between labels in the reference data, so as to improve resolution of separation between labels. We define the per-label score as a fixed quantile (by default, 0.8) of the correlations across all samples with that label. This accounts for differences in the number of reference samples for each label, which interferes with simpler flavors of nearest neighbor classification; it also avoids penalizing classifications to heterogeneous labels by only requiring a good match to a minority of samples. We repeat the score calculation for all labels in the reference dataset. The label with the highest score is used as SingleR’s prediction for this cell. We optionally perform a fine-tuning step to improve resolution between closely related labels. The reference dataset is subsetted to only include labels with scores close to the maximum; scores are recomputed using only marker genes for the subset of labels, thus focusing on the most relevant features; and this process is iterated until only one label remains. 1.3 Quick start We will demonstrate the use of SingleR() on a classic 10X Genomics dataset (Zheng et al. 2017) with the built-in Human Primary Cell Atlas dataset (Mabbott et al. 2013) as the reference. # Loading test data. library(TENxPBMCData) new.data &lt;- TENxPBMCData(&quot;pbmc4k&quot;) # Loading reference data with Ensembl annotations. library(SingleR) ref.data &lt;- HumanPrimaryCellAtlasData(ensembl=TRUE) # Performing predictions. predictions &lt;- SingleR(test=new.data, assay.type.test=1, ref=ref.data, labels=ref.data$label.main) table(predictions$labels) ## ## B_cell CMP DC GMP ## 606 8 1 2 ## Monocyte NK_cell Platelets Pre-B_cell_CD34- ## 1164 217 3 46 ## T_cells ## 2293 And that’s it, really. 1.4 Where to get help Questions on the general use of SingleR should be posted to the Bioconductor support site. Please send requests for general assistance and advice to the support site rather than to the individual authors. Bug reports or feature requests should be made to the GitHub repository; well-considered suggestions for improvements are always welcome. Session information View session info R version 4.0.0 Patched (2020-05-01 r78341) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 18.04.4 LTS Matrix products: default BLAS: /home/luna/Software/R/R-4-0-branch-dev/lib/libRblas.so LAPACK: /home/luna/Software/R/R-4-0-branch-dev/lib/libRlapack.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] parallel stats4 stats graphics grDevices utils datasets [8] methods base other attached packages: [1] ensembldb_2.13.1 AnnotationFilter_1.13.0 [3] GenomicFeatures_1.41.0 AnnotationDbi_1.51.0 [5] SingleR_1.3.4 TENxPBMCData_1.7.0 [7] HDF5Array_1.17.0 rhdf5_2.33.0 [9] SingleCellExperiment_1.11.1 SummarizedExperiment_1.19.4 [11] DelayedArray_0.15.1 matrixStats_0.56.0 [13] Biobase_2.49.0 GenomicRanges_1.41.1 [15] GenomeInfoDb_1.25.0 IRanges_2.23.4 [17] S4Vectors_0.27.6 BiocGenerics_0.35.2 [19] BiocStyle_2.17.0 rebook_0.99.0 loaded via a namespace (and not attached): [1] ProtGenerics_1.21.0 bitops_1.0-6 [3] bit64_0.9-7 progress_1.2.2 [5] httr_1.4.1 tools_4.0.0 [7] R6_2.4.1 irlba_2.3.3 [9] lazyeval_0.2.2 DBI_1.1.0 [11] prettyunits_1.1.1 tidyselect_1.1.0 [13] processx_3.4.2 bit_1.1-15.2 [15] curl_4.3 compiler_4.0.0 [17] graph_1.67.0 BiocNeighbors_1.7.0 [19] rtracklayer_1.49.1 bookdown_0.19 [21] askpass_1.1 callr_3.4.3 [23] rappdirs_0.3.1 Rsamtools_2.5.0 [25] stringr_1.4.0 digest_0.6.25 [27] rmarkdown_2.1 XVector_0.29.0 [29] pkgconfig_2.0.3 htmltools_0.4.0 [31] dbplyr_1.4.3 fastmap_1.0.1 [33] rlang_0.4.6 RSQLite_2.2.0 [35] shiny_1.4.0.2 DelayedMatrixStats_1.11.0 [37] BiocParallel_1.23.0 dplyr_0.8.5 [39] RCurl_1.98-1.2 magrittr_1.5 [41] BiocSingular_1.5.0 GenomeInfoDbData_1.2.3 [43] Matrix_1.2-18 Rcpp_1.0.4.6 [45] Rhdf5lib_1.11.0 lifecycle_0.2.0 [47] stringi_1.4.6 yaml_2.2.1 [49] zlibbioc_1.35.0 BiocFileCache_1.13.0 [51] AnnotationHub_2.21.0 grid_4.0.0 [53] blob_1.2.1 promises_1.1.0 [55] ExperimentHub_1.15.0 crayon_1.3.4 [57] lattice_0.20-41 beachmat_2.5.0 [59] Biostrings_2.57.0 hms_0.5.3 [61] CodeDepends_0.6.5 knitr_1.28 [63] ps_1.3.3 pillar_1.4.4 [65] codetools_0.2-16 biomaRt_2.45.0 [67] XML_3.99-0.3 glue_1.4.1 [69] BiocVersion_3.12.0 evaluate_0.14 [71] BiocManager_1.30.10 vctrs_0.3.0 [73] httpuv_1.5.2 openssl_1.4.1 [75] purrr_0.3.4 assertthat_0.2.1 [77] xfun_0.13 rsvd_1.0.3 [79] mime_0.9 xtable_1.8-4 [81] later_1.0.0 tibble_3.0.1 [83] GenomicAlignments_1.25.0 memoise_1.1.0 [85] ellipsis_0.3.1 interactiveDisplayBase_1.27.0 Bibliography "],
["using-the-built-in-references.html", "Chapter 2 Using the built-in references 2.1 Overview 2.2 Annotation with default marker detection 2.3 Interaction with quality control 2.4 Choices of assay data Session information", " Chapter 2 Using the built-in references .aaron-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .aaron-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 2.1 Overview SingleR detects markers in a pairwise manner between labels in the reference dataset. Specifically, for each label of interest, it performs pairwise comparisons to every other label in the reference and identifies the genes that are upregulated in the label of interest for each comparison. The initial score calculation is then performed on the union of marker genes across all comparisons for all label. This approach ensures that the selected subset of features will contain genes that distinguish each label from any other label. (In contrast, other approaches that treat the “other” labels as a single group do not offer this guarantee; see here for a discussion.) It also allows the fine-tuning step to aggressively improve resolution by only using marker genes from comparisons where both labels have scores close to the maximum. The original (“classic”) marker detection algorithm used in Aran et al. (2019) identified marker genes based on their log-fold changes in each pairwise comparison. Specifically, it used the genes with the largest positive differences in the per-label median log-expression values between labels. The number of genes taken from each pairwise comparison was defined as \\(500 (\\frac{2}{3})^{\\log_{2}(n)}\\), where \\(n\\) is the number of unique labels in the reference; this aimed to reduce the number of genes (and thus the computational time) as the number of labels and pairwise comparisons increased. This classic mode is primarily intended for reference datasets that have little or no replication, a description that covers most of the built-in references and precludes more complicated marker detection procedures (Chapter 3). 2.2 Annotation with default marker detection For demonstration purposes, we will use the Grun et al. (2016) haematopoietic stem cell (HSC) dataset from the scRNAseq package. The GrunHSCData() function conveniently returns a SingleCellExperiment object containing the count matrix for this dataset. library(scRNAseq) sce &lt;- GrunHSCData(ensembl=TRUE) sce ## class: SingleCellExperiment ## dim: 21817 1915 ## metadata(0): ## assays(1): counts ## rownames(21817): ENSMUSG00000109644 ENSMUSG00000007777 ... ## ENSMUSG00000055670 ENSMUSG00000039068 ## rowData names(3): symbol chr originalName ## colnames(1915): JC4_349_HSC_FE_S13_ JC4_350_HSC_FE_S13_ ... ## JC48P6_1203_HSC_FE_S8_ JC48P6_1204_HSC_FE_S8_ ## colData names(2): sample protocol ## reducedDimNames(0): ## altExpNames(0): Our plan is to annotate each cell with the built-in ImmGen reference dataset (Heng et al. 2008). Calling the ImmGenData() function returns a SummarizedExperiment object containing a matrix of log-expression values with sample-level labels. We set ensembl=TRUE to match the reference’s gene annotation with that in the sce object (the default behavior is to use the gene symbol). library(SingleR) immgen &lt;- ImmGenData(ensembl=TRUE) immgen ## class: SummarizedExperiment ## dim: 21352 830 ## metadata(0): ## assays(1): logcounts ## rownames(21352): ENSMUSG00000079681 ENSMUSG00000066372 ... ## ENSMUSG00000034640 ENSMUSG00000036940 ## rowData names(0): ## colnames(830): ## GSM1136119_EA07068_260297_MOGENE-1_0-ST-V1_MF.11C-11B+.LU_1.CEL ## GSM1136120_EA07068_260298_MOGENE-1_0-ST-V1_MF.11C-11B+.LU_2.CEL ... ## GSM920654_EA07068_201214_MOGENE-1_0-ST-V1_TGD.VG4+24ALO.E17.TH_1.CEL ## GSM920655_EA07068_201215_MOGENE-1_0-ST-V1_TGD.VG4+24ALO.E17.TH_2.CEL ## colData names(3): label.main label.fine label.ont Technically speaking, each built-in dataset actually has three sets of labels that primarily differ in their resolution. For the purposes of this demonstration, we will use the “fine” labels in the label.fine metadata field, which represents the highest resolution of annotation available in ImmGen. head(immgen$label.fine) ## [1] &quot;Macrophages (MF.11C-11B+)&quot; &quot;Macrophages (MF.11C-11B+)&quot; ## [3] &quot;Macrophages (MF.11C-11B+)&quot; &quot;Macrophages (MF.ALV)&quot; ## [5] &quot;Macrophages (MF.ALV)&quot; &quot;Macrophages (MF.ALV)&quot; Annotation is then a simple matter of calling SingleR() on our test (Grun) dataset and the reference (ImmGen) dataset, leaving the default of de.method=&quot;classic&quot; to use the original marker detection scheme. This applies the algorithm described in Section 1.2, returning a DataFrame where each row contains prediction results for a single cell in the sce object. Labels are provided before fine-tuning (first.labels), after fine-tuning (labels) and after pruning (pruned.labels); some of the other fields are discussed in more detail in Chapter 4. # See &#39;Choices of assay data&#39; for &#39;assay.type.test=&#39; explanation. pred &lt;- SingleR(test = sce, ref = immgen, labels = immgen$label.fine, assay.type.test=1) colnames(pred) ## [1] &quot;scores&quot; &quot;first.labels&quot; &quot;tuning.scores&quot; &quot;labels&quot; ## [5] &quot;pruned.labels&quot; 2.3 Interaction with quality control Upon examining the distribution of assigned labels, we see that many of them are related to stem cells. However, there are quite a large number of more differentiated labels mixed in, which is not what we expect from a sorted population of HSCs. head(sort(table(pred$labels), decreasing=TRUE)) ## ## Stem cells (SC.MEP) Neutrophils (GN.ARTH) Macrophages (MF) ## 362 314 165 ## Stem cells (SC.STSL) B cells (proB.FrA) Stem cells (SC.LT34F) ## 142 121 103 This is probably because - despite what its name might suggest - the dataset obtained by GrunHSCData() actually contains more than HSCs. If we restrict our analysis to the sorted HSCs (obviously) and remove one low-quality batch (see the analysis here for the rationale) we can see that the distribution of cell type labels is more similar to what we might expect. Low-quality cells - typically those with low library sizes and low numbers of detected genes - lack information for accurate label assignment and often need to be removed to enable interpretation of the results. actual.hsc &lt;- pred$labels[sce$protocol==&quot;sorted hematopoietic stem cells&quot; &amp; sce$sample!=&quot;JC4&quot;] head(sort(table(actual.hsc), decreasing=TRUE)) ## actual.hsc ## Stem cells (SC.STSL) Stem cells (SC.LT34F) ## 109 98 ## Stem cells (SC.ST34F) Stem cells (SC.CD150-CD48-) ## 37 15 ## Stem cells (LTHSC) Stem cells (MLP) ## 12 8 Filtering the annotation results in the above manner is possible because SingleR() operates independently on each cell. The annotation is orthogonal to any decisions about the relative quality of the cells in the test dataset; the same results will be obtained regardless of whether the annotation is performed before or after quality control. This is logisitically convenient as it means that the annotation does not have to be repeated if the quality control scheme (or any other downstream step, like clustering) changes throughout the lifetime of the analysis. 2.4 Choices of assay data For the reference dataset, the assay matrix must contain log-transformed normalized expression values. This is because the default marker detection scheme computes log-fold changes by subtracting the medians, which makes little sense unless the input expression values are already log-transformed. For alternative schemes, this requirement may be relaxed (e.g., Wilcoxon rank sum tests do not require transformation); similarly, if pre-defined markers are supplied, no transformation or normalization is necessary. For the test data, the assay data need not be log-transformed or even (scale) normalized. This is because SingleR() computes Spearman correlations within each cell, which is unaffected by monotonic transformations like cell-specific scaling or log-transformation. It is perfectly satisfactory to provide the raw counts for the test dataset to SingleR(), which is the reason for setting assay.type.test=1 in our previous SingleR() call for the Grun dataset. The exception to this rule occurs when comparing data from full-length technologies to the built-in references. The built-in references are constructed to be comparable to unique molecular identifier (UMI) protocols, where the expression values are less sensitive to differences in gene length. Thus, when comparing Smart-seq2 test datasets to the built-in references, better performance can often be achieved by processing the test counts to transcripts-per-million values. We demonstrate below using another HSC dataset that was generated using the Smart-seq2 protocol (Nestorowa et al. 2016). Again, we see that most of the predicted labels are related to stem cells, which is comforting. sce.nest &lt;- NestorowaHSCData() # Getting the exonic gene lengths. library(AnnotationHub) mm.db &lt;- AnnotationHub()[[&quot;AH73905&quot;]] mm.exons &lt;- exonsBy(mm.db, by=&quot;gene&quot;) mm.exons &lt;- reduce(mm.exons) mm.len &lt;- sum(width(mm.exons)) # Computing the TPMs with a simple scaling by gene length. library(scater) keep &lt;- intersect(names(mm.len), rownames(sce.nest)) tpm.nest &lt;- calculateTPM(sce.nest[keep,], lengths=mm.len[keep]) # Performing the assignment. pred &lt;- SingleR(test = tpm.nest, ref = immgen, labels = immgen$label.fine) head(sort(table(pred$labels), decreasing=TRUE), 10) ## ## Stem cells (SC.MEP) Stem cells (SC.ST34F) ## 409 357 ## Stem cells (SC.MPP34F) Stem cells (SC.CMP.DR) ## 329 298 ## Stem cells (MLP) Stem cells (GMP) ## 167 102 ## Stem cells (SC.STSL) Stem cells (SC.MDP) ## 71 66 ## Stem cells (SC.CD150-CD48-) Stem cells (SC.LT34F) ## 55 37 Session information View session info R version 4.0.0 Patched (2020-05-01 r78341) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 18.04.4 LTS Matrix products: default BLAS: /home/luna/Software/R/R-4-0-branch-dev/lib/libRblas.so LAPACK: /home/luna/Software/R/R-4-0-branch-dev/lib/libRlapack.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 parallel stats graphics grDevices utils datasets [8] methods base other attached packages: [1] scater_1.17.0 ggplot2_3.3.0 [3] AnnotationHub_2.21.0 BiocFileCache_1.13.0 [5] dbplyr_1.4.3 SingleR_1.3.4 [7] ensembldb_2.13.1 AnnotationFilter_1.13.0 [9] GenomicFeatures_1.41.0 AnnotationDbi_1.51.0 [11] scRNAseq_2.3.0 SingleCellExperiment_1.11.1 [13] SummarizedExperiment_1.19.4 DelayedArray_0.15.1 [15] matrixStats_0.56.0 Biobase_2.49.0 [17] GenomicRanges_1.41.1 GenomeInfoDb_1.25.0 [19] IRanges_2.23.4 S4Vectors_0.27.6 [21] BiocGenerics_0.35.2 BiocStyle_2.17.0 [23] rebook_0.99.0 loaded via a namespace (and not attached): [1] ProtGenerics_1.21.0 bitops_1.0-6 [3] bit64_0.9-7 progress_1.2.2 [5] httr_1.4.1 tools_4.0.0 [7] irlba_2.3.3 R6_2.4.1 [9] vipor_0.4.5 colorspace_1.4-1 [11] DBI_1.1.0 lazyeval_0.2.2 [13] withr_2.2.0 gridExtra_2.3 [15] tidyselect_1.1.0 prettyunits_1.1.1 [17] processx_3.4.2 bit_1.1-15.2 [19] curl_4.3 compiler_4.0.0 [21] graph_1.67.0 BiocNeighbors_1.7.0 [23] rtracklayer_1.49.1 bookdown_0.19 [25] scales_1.1.1 callr_3.4.3 [27] askpass_1.1 rappdirs_0.3.1 [29] stringr_1.4.0 digest_0.6.25 [31] Rsamtools_2.5.0 rmarkdown_2.1 [33] XVector_0.29.0 pkgconfig_2.0.3 [35] htmltools_0.4.0 fastmap_1.0.1 [37] rlang_0.4.6 RSQLite_2.2.0 [39] DelayedMatrixStats_1.11.0 shiny_1.4.0.2 [41] BiocParallel_1.23.0 dplyr_0.8.5 [43] BiocSingular_1.5.0 RCurl_1.98-1.2 [45] magrittr_1.5 GenomeInfoDbData_1.2.3 [47] Matrix_1.2-18 ggbeeswarm_0.6.0 [49] munsell_0.5.0 Rcpp_1.0.4.6 [51] viridis_0.5.1 lifecycle_0.2.0 [53] stringi_1.4.6 yaml_2.2.1 [55] zlibbioc_1.35.0 grid_4.0.0 [57] blob_1.2.1 promises_1.1.0 [59] ExperimentHub_1.15.0 crayon_1.3.4 [61] lattice_0.20-41 Biostrings_2.57.0 [63] hms_0.5.3 CodeDepends_0.6.5 [65] knitr_1.28 ps_1.3.3 [67] pillar_1.4.4 codetools_0.2-16 [69] biomaRt_2.45.0 XML_3.99-0.3 [71] glue_1.4.1 BiocVersion_3.12.0 [73] evaluate_0.14 BiocManager_1.30.10 [75] vctrs_0.3.0 httpuv_1.5.2 [77] gtable_0.3.0 openssl_1.4.1 [79] purrr_0.3.4 assertthat_0.2.1 [81] xfun_0.13 rsvd_1.0.3 [83] mime_0.9 xtable_1.8-4 [85] later_1.0.0 viridisLite_0.3.0 [87] tibble_3.0.1 beeswarm_0.2.3 [89] GenomicAlignments_1.25.0 memoise_1.1.0 [91] ellipsis_0.3.1 interactiveDisplayBase_1.27.0 Bibliography "],
["using-single-cell-references.html", "Chapter 3 Using single-cell references 3.1 Overview 3.2 Annotation with test-based marker detection 3.3 Defining custom markers 3.4 Pseudo-bulk aggregation Session information", " Chapter 3 Using single-cell references .aaron-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .aaron-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 3.1 Overview Another application of SingleR involves using one single-cell dataset as a reference to annotate other single-cell datasets. This is almost identical to the use of the built-in bulk references described in Chapter 2, with the main difference involving the marker detection strategy that is applied to the reference labels. In particular, we identify top-ranked markers based on pairwise Wilcoxon rank sum tests or \\(t\\)-tests between labels; this allows us to account for the variability across cells to choose genes that are robustly upregulated in each label. Despite the name of this chapter, the functionality described here is not limited to single-cell references. The determining factor is whether a dataset contains enough samples for each label to permit the use of statistical tests for marker detection. This scenario is most common for single-cell references but the same approach can be applied to bulk references with many replicate samples. 3.2 Annotation with test-based marker detection To demonstrate, we will use two human pancreas scRNA-seq datasets from the scRNAseq package. The aim is to use one pre-labelled dataset to annotate the other unlabelled dataset. First, we set up the Muraro et al. (2016) dataset to be our reference, computing log-normalized expression values as discussed in Section 2.4. library(scRNAseq) sceM &lt;- MuraroPancreasData() # Removing unlabelled cells or cells without a clear label. sceM &lt;- sceM[,!is.na(sceM$label) &amp; sceM$label!=&quot;unclear&quot;] library(scater) sceM &lt;- logNormCounts(sceM) sceM ## class: SingleCellExperiment ## dim: 19059 2122 ## metadata(0): ## assays(2): counts logcounts ## rownames(19059): A1BG-AS1__chr19 A1BG__chr19 ... ZZEF1__chr17 ## ZZZ3__chr1 ## rowData names(2): symbol chr ## colnames(2122): D28-1_1 D28-1_2 ... D30-8_93 D30-8_94 ## colData names(4): label donor plate sizeFactor ## reducedDimNames(0): ## altExpNames(1): ERCC # Seeing the available labels in this dataset. table(sceM$label) ## ## acinar alpha beta delta duct endothelial ## 219 812 448 193 245 21 ## epsilon mesenchymal pp ## 3 80 101 We then set up our test dataset from Grun et al. (2016), applying some basic quality control as discusssed here and in Section 2.3. We also compute the log-transformed values here, not because it is strictly necessary but so that we don’t have to keep on typing assay.type.test=1 in later calls to SingleR(). sceG &lt;- GrunPancreasData() sceG &lt;- addPerCellQC(sceG) qc &lt;- quickPerCellQC(colData(sceG), percent_subsets=&quot;altexps_ERCC_percent&quot;, batch=sceG$donor, subset=sceG$donor %in% c(&quot;D17&quot;, &quot;D7&quot;, &quot;D2&quot;)) sceG &lt;- sceG[,!qc$discard] sceG &lt;- logNormCounts(sceG) sceG ## class: SingleCellExperiment ## dim: 20064 1064 ## metadata(0): ## assays(2): counts logcounts ## rownames(20064): A1BG-AS1__chr19 A1BG__chr19 ... ZZEF1__chr17 ## ZZZ3__chr1 ## rowData names(2): symbol chr ## colnames(1064): D2ex_1 D2ex_2 ... D17TGFB_94 D17TGFB_95 ## colData names(13): donor sample ... total sizeFactor ## reducedDimNames(0): ## altExpNames(1): ERCC We run SingleR() as described previously but with a marker detection mode that considers the variance of expression across cells. Here, we will use the Wilcoxon ranked sum test to identify the top markers for each pairwise comparison between labels. This is slower but more appropriate for single-cell data compared to the default marker detection algorithm, as the latter may fail for low-coverage data where the median for each label is often zero. library(SingleR) pred.grun &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, de.method=&quot;wilcox&quot;) table(pred.grun$labels) ## ## acinar alpha beta delta duct endothelial ## 277 203 181 50 306 5 ## epsilon mesenchymal pp ## 1 22 19 By default, the function will take the top de.n (default: 10) genes from each pairwise comparison between labels. A larger number of markers increases the robustness of the annotation by ensuring that relevant genes are not omitted, especially if the reference dataset has study-specific effects that cause uninteresting genes to dominate the top set. However, this comes at the cost of increasing noise and computational time. library(SingleR) pred.grun &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, de.method=&quot;wilcox&quot;, de.n=50) table(pred.grun$labels) ## ## acinar alpha beta delta duct endothelial ## 275 203 177 55 307 5 ## epsilon mesenchymal pp ## 1 23 18 3.3 Defining custom markers The marker detection in SingleR() is built on top of the testing framework in scran, so most options in ?pairwiseWilcox and friends can be applied via the de.args= option. For example, we could use the \\(t\\)-test and test against a log-fold change threshold with de.args=list(lfc=1). library(SingleR) pred.grun2 &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, de.method=&quot;t&quot;, de.args=list(lfc=1)) table(pred.grun2$labels) ## ## acinar alpha beta delta duct endothelial ## 285 200 177 54 296 5 ## epsilon mesenchymal pp ## 5 24 18 However, users can also construct their own marker lists with any DE testing machinery. For example, we can perform pairwise binomial tests to identify genes that are differentially detected (i.e., have differences in the proportion of cells with non-zero counts) between labels in the reference Muraro dataset. We then take the top 10 marker genes from each pairwise comparison, obtaining a list of lists of character vectors containing the identities of the markers for that comparison. library(scran) out &lt;- pairwiseBinom(counts(sceM), sceM$label, direction=&quot;up&quot;) markers &lt;- getTopMarkers(out$statistics, out$pairs, n=10) # Upregulated in acinar compared to alpha: markers$acinar$alpha ## [1] &quot;KCNQ1__chr11&quot; &quot;FAM129A__chr1&quot; &quot;KLK1__chr19&quot; &quot;NTN4__chr12&quot; ## [5] &quot;RASEF__chr9&quot; &quot;CTRL__chr16&quot; &quot;LGALS2__chr22&quot; &quot;NUPR1__chr16&quot; ## [9] &quot;LGALS3__chr14&quot; &quot;NR5A2__chr1&quot; # Upregulated in alpha compared to acinar: markers$alpha$acinar ## [1] &quot;SLC38A4__chr12&quot; &quot;ARX__chrX&quot; &quot;CRYBA2__chr2&quot; &quot;FSTL5__chr4&quot; ## [5] &quot;GNG2__chr14&quot; &quot;NOL4__chr18&quot; &quot;IRX2__chr5&quot; &quot;KCNMB2__chr3&quot; ## [9] &quot;CFC1__chr2&quot; &quot;KCNJ6__chr21&quot; Once we have this list of lists, we supply it to SingleR() via the genes= argument, which causes the function to bypass the internal marker detection to use the supplied gene sets instead. The most obvious benefit of this approach is that the user can achieve greater control of the markers, allowing integration of prior biological knowledge to obtain more relevant genes and a more robust annotation. pred.grun2b &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, genes=markers) table(pred.grun2b$labels) ## ## acinar alpha beta delta duct endothelial ## 276 202 175 54 302 5 ## epsilon mesenchymal pp ## 2 25 23 In some cases, markers may only be available for specific labels rather than for pairwise comparisons between labels. This is accommodated by supplying a named list of character vectors to genes. Note that this is likely to be less powerful than the list-of-lists approach as information about pairwise differences is discarded. # Creating label-specific markers. label.markers &lt;- lapply(markers, unlist) label.markers &lt;- lapply(label.markers, unique) str(label.markers) ## List of 9 ## $ acinar : chr [1:40] &quot;KCNQ1__chr11&quot; &quot;FAM129A__chr1&quot; &quot;KLK1__chr19&quot; &quot;NTN4__chr12&quot; ... ## $ alpha : chr [1:41] &quot;SLC38A4__chr12&quot; &quot;ARX__chrX&quot; &quot;CRYBA2__chr2&quot; &quot;FSTL5__chr4&quot; ... ## $ beta : chr [1:47] &quot;ELAVL4__chr1&quot; &quot;PRUNE2__chr9&quot; &quot;NMNAT2__chr1&quot; &quot;PLCB4__chr20&quot; ... ## $ delta : chr [1:44] &quot;NOL4__chr18&quot; &quot;CABP7__chr22&quot; &quot;UNC80__chr2&quot; &quot;HEPACAM2__chr7&quot; ... ## $ duct : chr [1:50] &quot;ADCY5__chr3&quot; &quot;PDE3A__chr12&quot; &quot;SLC3A1__chr2&quot; &quot;BICC1__chr10&quot; ... ## $ endothelial: chr [1:26] &quot;GPR4__chr19&quot; &quot;TMEM204__chr16&quot; &quot;GPR116__chr6&quot; &quot;CYYR1__chr21&quot; ... ## $ epsilon : chr [1:14] &quot;BHMT__chr5&quot; &quot;JPH3__chr16&quot; &quot;SERPINA10__chr14&quot; &quot;UGT2B4__chr4&quot; ... ## $ mesenchymal: chr [1:34] &quot;TNFAIP6__chr2&quot; &quot;THBS2__chr6&quot; &quot;CDH11__chr16&quot; &quot;SRPX2__chrX&quot; ... ## $ pp : chr [1:44] &quot;SERTM1__chr13&quot; &quot;ETV1__chr7&quot; &quot;ARX__chrX&quot; &quot;ELAVL4__chr1&quot; ... pred.grun2c &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, genes=label.markers) table(pred.grun2c$labels) ## ## acinar alpha beta delta duct endothelial ## 262 204 169 59 317 6 ## epsilon mesenchymal pp ## 2 24 21 3.4 Pseudo-bulk aggregation Single-cell reference datasets provide a like-for-like comparison to our test single-cell datasets, yielding a more accurate classification of the cells in the latter (hopefully). However, there are frequently many more samples in single-cell references compared to bulk references, increasing the computational work involved in classification. We overcome this by aggregating cells into one “pseudo-bulk” sample per label (e.g., by averaging across log-expression values) and using that as the reference profile, which allows us to achieve the same efficiency as the use of bulk references. The obvious cost of this approach is that we discard potentially useful information about the distribution of cells within each label. Cells that belong to a heterogeneous population may not be correctly assigned if they are far from the population center. To preserve some of this information, we perform \\(k\\)-means clustering within each label to create pseudo-bulk samples that are representative of a particular region of the expression space (i.e., vector quantization). We create \\(\\sqrt{N}\\) clusters given a label with \\(N\\) cells, which provides a reasonable compromise between reducing computational work and preserving the label’s internal distribution. To enable this aggregation, we simply set aggr.ref=TRUE in the SingleR() call. This uses the aggregateReference() function to perform \\(k\\)-means clustering within each label (typically after principal components analysis on the log-expression matrix, for greater speed) and average expression values for each within-label cluster. Note that marker detection is still performed on the unaggregated data so as to make full use of the distribution of expression values across cells. set.seed(100) # for the k-means step. pred.grun3 &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, de.method=&quot;wilcox&quot;, aggr.ref=TRUE) table(pred.grun3$labels) ## ## acinar alpha beta delta duct endothelial ## 277 202 184 47 306 5 ## epsilon mesenchymal pp ## 1 22 20 Obviously, the aggregation itself requires computational work so setting aggr.ref=TRUE in SingleR() itself may not improve speed. Rather, the real power of this approach lies in pre-aggregating the reference dataset so that it can be repeatedly applied to quickly annotate multiple test datasets. This approach is discussed in more detail in Chapter 7. Session information View session info R version 4.0.0 Patched (2020-05-01 r78341) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 18.04.4 LTS Matrix products: default BLAS: /home/luna/Software/R/R-4-0-branch-dev/lib/libRblas.so LAPACK: /home/luna/Software/R/R-4-0-branch-dev/lib/libRlapack.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] parallel stats4 stats graphics grDevices utils datasets [8] methods base other attached packages: [1] scran_1.17.0 SingleR_1.3.4 [3] scater_1.17.0 ggplot2_3.3.0 [5] scRNAseq_2.3.0 SingleCellExperiment_1.11.1 [7] SummarizedExperiment_1.19.4 DelayedArray_0.15.1 [9] matrixStats_0.56.0 Biobase_2.49.0 [11] GenomicRanges_1.41.1 GenomeInfoDb_1.25.0 [13] IRanges_2.23.4 S4Vectors_0.27.6 [15] BiocGenerics_0.35.2 BiocStyle_2.17.0 [17] rebook_0.99.0 loaded via a namespace (and not attached): [1] bitops_1.0-6 bit64_0.9-7 [3] httr_1.4.1 tools_4.0.0 [5] R6_2.4.1 irlba_2.3.3 [7] vipor_0.4.5 DBI_1.1.0 [9] colorspace_1.4-1 withr_2.2.0 [11] gridExtra_2.3 tidyselect_1.1.0 [13] processx_3.4.2 bit_1.1-15.2 [15] curl_4.3 compiler_4.0.0 [17] graph_1.67.0 BiocNeighbors_1.7.0 [19] bookdown_0.19 scales_1.1.1 [21] callr_3.4.3 rappdirs_0.3.1 [23] stringr_1.4.0 digest_0.6.25 [25] rmarkdown_2.1 XVector_0.29.0 [27] pkgconfig_2.0.3 htmltools_0.4.0 [29] limma_3.45.0 dbplyr_1.4.3 [31] fastmap_1.0.1 rlang_0.4.6 [33] RSQLite_2.2.0 shiny_1.4.0.2 [35] DelayedMatrixStats_1.11.0 BiocParallel_1.23.0 [37] dplyr_0.8.5 RCurl_1.98-1.2 [39] magrittr_1.5 BiocSingular_1.5.0 [41] scuttle_0.99.6 GenomeInfoDbData_1.2.3 [43] Matrix_1.2-18 Rcpp_1.0.4.6 [45] ggbeeswarm_0.6.0 munsell_0.5.0 [47] viridis_0.5.1 lifecycle_0.2.0 [49] edgeR_3.31.0 stringi_1.4.6 [51] yaml_2.2.1 zlibbioc_1.35.0 [53] BiocFileCache_1.13.0 AnnotationHub_2.21.0 [55] grid_4.0.0 blob_1.2.1 [57] dqrng_0.2.1 promises_1.1.0 [59] ExperimentHub_1.15.0 crayon_1.3.4 [61] lattice_0.20-41 locfit_1.5-9.4 [63] CodeDepends_0.6.5 knitr_1.28 [65] ps_1.3.3 pillar_1.4.4 [67] igraph_1.2.5 codetools_0.2-16 [69] XML_3.99-0.3 glue_1.4.1 [71] BiocVersion_3.12.0 evaluate_0.14 [73] BiocManager_1.30.10 vctrs_0.3.0 [75] httpuv_1.5.2 gtable_0.3.0 [77] purrr_0.3.4 assertthat_0.2.1 [79] xfun_0.13 rsvd_1.0.3 [81] mime_0.9 xtable_1.8-4 [83] later_1.0.0 viridisLite_0.3.0 [85] tibble_3.0.1 AnnotationDbi_1.51.0 [87] beeswarm_0.2.3 memoise_1.1.0 [89] statmod_1.4.34 ellipsis_0.3.1 [91] interactiveDisplayBase_1.27.0 Bibliography "],
["annotation-diagnostics.html", "Chapter 4 Annotation diagnostics 4.1 Overview 4.2 Based on the scores within cells 4.3 Based on the deltas across cells 4.4 Based on marker gene expression Session information", " Chapter 4 Annotation diagnostics .aaron-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .aaron-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 4.1 Overview In addition to the labels, SingleR() returns a number of helpful diagnostics about the annotation process that can be used to determine whether the assignments are appropriate. Unambiguous assignments corroborated by expression of canonical markers add confidence to the results; conversely, low-confidence assignments can be pruned out to avoid adding noise to downstream analyses. This chapter will demonstrate some of these common sanity checks on the pancreas datasets from Chapter 3 (Muraro et al. 2016; Grun et al. 2016). View history #--- loading-muraro ---# library(scRNAseq) sceM &lt;- MuraroPancreasData() sceM &lt;- sceM[,!is.na(sceM$label) &amp; sceM$label!=&quot;unclear&quot;] library(scater) sceM &lt;- logNormCounts(sceM) #--- loading-grun ---# sceG &lt;- GrunPancreasData() sceG &lt;- addPerCellQC(sceG) qc &lt;- quickPerCellQC(colData(sceG), percent_subsets=&quot;altexps_ERCC_percent&quot;, batch=sceG$donor, subset=sceG$donor %in% c(&quot;D17&quot;, &quot;D7&quot;, &quot;D2&quot;)) sceG &lt;- sceG[,!qc$discard] sceG &lt;- logNormCounts(sceG) #--- annotation ---# library(SingleR) pred.grun &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, de.method=&quot;wilcox&quot;) 4.2 Based on the scores within cells The most obvious diagnostic reported by SingleR() is the nested matrix of per-cell scores in the scores field. This contains the correlation-based scores prior to any fine-tuning for each cell (row) and reference label (column). Ideally, we would see unambiguous assignments where, for any given cell, one label’s score is clearly larger than the others. pred.grun$scores[1:10,] ## acinar alpha beta delta duct endothelial epsilon mesenchymal ## [1,] 0.6797 0.1463 0.1554 0.1029 0.4971 0.2030 0.04434 0.1848 ## [2,] 0.6832 0.1849 0.1611 0.1250 0.5133 0.2231 0.08909 0.2140 ## [3,] 0.6845 0.2032 0.2141 0.1875 0.5060 0.2286 0.08960 0.1961 ## [4,] 0.6472 0.2050 0.2115 0.1879 0.7300 0.2285 0.12107 0.2708 ## [5,] 0.6079 0.2285 0.2419 0.1938 0.6616 0.2659 0.16007 0.3228 ## [6,] 0.5816 0.2789 0.2611 0.2661 0.6827 0.2857 0.21781 0.3151 ## [7,] 0.5704 0.3268 0.2990 0.2618 0.6293 0.2947 0.20834 0.3263 ## [8,] 0.5692 0.2455 0.2152 0.2033 0.6495 0.2652 0.18469 0.2943 ## [9,] 0.6421 0.2101 0.1929 0.1894 0.7201 0.2795 0.14615 0.3142 ## [10,] 0.7153 0.2109 0.1747 0.1606 0.5896 0.1687 0.15639 0.1778 ## pp ## [1,] 0.08954 ## [2,] 0.11207 ## [3,] 0.15207 ## [4,] 0.14351 ## [5,] 0.18475 ## [6,] 0.21898 ## [7,] 0.25871 ## [8,] 0.19160 ## [9,] 0.17281 ## [10,] 0.16314 To check whether this is indeed the case, we use the plotScoreHeatmap() function to visualize the score matrix (Figure 4.1). Here, the key is to examine the spread of scores within each cell, i.e., down the columns of the heatmap. Similar scores for a group of labels indicates that the assignment is uncertain for those columns, though this may be acceptable if the uncertainty is distributed across closely related cell types. library(SingleR) plotScoreHeatmap(pred.grun) Figure 4.1: Heatmap of normalized scores for the Grun dataset. Each cell is a column while each row is a label in the reference Muraro dataset. The final label (after fine-tuning) for each cell is shown in the top color bar. We can also display other metadata information for each cell by setting clusters= or annotation_col=. This is occasionally useful for examining potential batch effects, differences in cell type composition between conditions, relationship to clusters from an unsupervised analysis and so on,. For example, Figure 4.2 displays the donor of origin for each cell; we can see that each cell type has contributions from multiple donors, which is reassuring as it indicates that our assignments are not (purely) driven by donor effects. plotScoreHeatmap(pred.grun, annotation_col=as.data.frame(colData(sceG)[,&quot;donor&quot;,drop=FALSE])) Figure 4.2: Heatmap of normalized scores for the Grun dataset, including the donor of origin for each cell. The scores matrix has several caveats associated with its interpretation. Only the pre-tuned scores are stored in this matrix, as scores after fine-tuning are not comparable across all labels. This means that the label with the highest score for a cell may not be the cell’s final label if fine-tuning is applied. Moreover, the magnitude of differences in the scores has no clear interpretation; indeed, plotScoreHeatmap() dispenses with any faithful representation of the scores and instead adjusts the values to highlight any differences between labels within each cell. 4.3 Based on the deltas across cells We identify poor-quality or ambiguous assignments based on the per-cell “delta”, i.e., the difference between the score for the assigned label and the median across all labels for each cell. Our assumption is that most of the labels in the reference are not relevant to any given cell. Thus, the median across all labels can be used as a measure of the baseline correlation, while the gap from the assigned label to this baseline can be used as a measure of the assignment confidence. Low deltas indicate that the assignment is uncertain, possibly because the cell’s true label does not exist in the reference. An obvious next step is to apply a threshold on the delta to filter out these low-confidence assignments. We use the delta rather than the assignment score as the latter is more sensitive to technical effects. For example, changes in library size affect the technical noise and can increase/decrease all scores for a given cell, while the delta is somewhat more robust as it focuses on the differences between scores within each cell. SingleR() will set a threshold on the delta for each label using an outlier-based strategy. Specifically, we identify cells with deltas that are small outliers relative to the deltas of other cells with the same label. This assumes that, for any given label, most cells assigned to that label are correct. We focus on outliers to avoid difficulties with setting a fixed threshold, especially given that the magnitudes of the deltas are about as uninterpretable as the scores themselves. Pruned labels are reported in the pruned.labels field where low-quality assignments are replaced with NA. to.remove &lt;- is.na(pred.grun$pruned.labels) table(Label=pred.grun$labels, Removed=to.remove) ## Removed ## Label FALSE TRUE ## acinar 251 26 ## alpha 198 5 ## beta 180 1 ## delta 49 1 ## duct 301 5 ## endothelial 4 1 ## epsilon 1 0 ## mesenchymal 22 0 ## pp 17 2 However, the default pruning parameters may not be appropriate for every dataset. For example, if one label is consistently misassigned, the assumption that most cells are correctly assigned will not be appropriate. In such cases, we can revert to a fixed threshold by manually calling the underlying pruneScores() function with min.diff.med=. The example below discards cells with deltas below an arbitrary threshold of 0.2, where higher thresholds correspond to greater assignment certainty. to.remove &lt;- pruneScores(pred.grun, min.diff.med=0.2) table(Label=pred.grun$labels, Removed=to.remove) ## Removed ## Label FALSE TRUE ## acinar 250 27 ## alpha 155 48 ## beta 148 33 ## delta 33 17 ## duct 301 5 ## endothelial 4 1 ## epsilon 0 1 ## mesenchymal 22 0 ## pp 4 15 This entire process can be visualized using the plotScoreDistribution() function, which displays the per-label distribution of the deltas across cells (Figure 4.3). We can use this plot to check that outlier detection in pruneScores() behaved sensibly. Labels with especially low deltas may warrant some additional caution in their interpretation. plotDeltaDistribution(pred.grun) Figure 4.3: Distribution of deltas for the Grun dataset. Each facet represents a label in the Muraro dataset, and each point represents a cell assigned to that label (colored by whether it was pruned). If fine-tuning was performed, we can apply an even more stringent filter based on the difference between the highest and second-highest scores after fine-tuning. Cells will only pass the filter if they are assigned to a label that is clearly distinguishable from any other label. In practice, this approach tends to be too conservative as assignments involving closely related labels are heavily penalized. to.remove2 &lt;- pruneScores(pred.grun, min.diff.next=0.1) table(Label=pred.grun$labels, Removed=to.remove2) ## Removed ## Label FALSE TRUE ## acinar 235 42 ## alpha 166 37 ## beta 117 64 ## delta 25 25 ## duct 157 149 ## endothelial 4 1 ## epsilon 0 1 ## mesenchymal 22 0 ## pp 9 10 4.4 Based on marker gene expression Another simple yet effective diagnostic is to examine the expression of the marker genes for each label in the test dataset. The marker genes used for each label are reported in the metadata() of the SingleR() output, so we can simply retrieve them to visualize their (usually log-transformed) expression values across the test dataset. Here, we use the plotHeatmap() function from scater to examine the expression of markers used to identify beta cells (Figure 4.4). all.markers &lt;- metadata(pred.grun)$de.genes sceG$labels &lt;- pred.grun$labels library(scater) plotHeatmap(sceG, order_columns_by=&quot;labels&quot;, features=unique(unlist(all.markers$beta))) Figure 4.4: Heatmap of log-expression values in the Grun dataset for all marker genes upregulated in beta cells in the Muraro reference dataset. Assigned labels for each cell are shown at the top of the plot. If a cell in the test dataset is confidently assigned to a particular label, we would expect it to have strong expression of that label’s markers. We would also hope that those label’s markers are biologically meaningful; in this case, we do observe strong upregulation of insulin (INS) in the beta cells, which is reassuring and gives greater confidence to the correctness of the assignment. If the identified markers are not meaningful or not consistently upregulated, some skepticism towards the quality of the assignments is warranted. It is straightforward to repeat this process for all labels by wrapping this code in a loop, as shown below in Figure 4.5. Note that plotHeatmap() is not the only function that can be used for this visualization; we could also use plotDots() to create a Seurat-style dot plot, or we could use other heatmap plotting functions such as dittoHeatmap() from dittoSeq. collected &lt;- list() for (lab in unique(pred.grun$labels)) { collected[[lab]] &lt;- plotHeatmap(sceG, silent=TRUE, order_columns_by=&quot;labels&quot;, main=lab, features=unique(unlist(all.markers[[lab]])))[[4]] } do.call(gridExtra::grid.arrange, collected) Figure 4.5: Heatmaps of log-expression values in the Grun dataset for all marker genes upregulated in each label in the Muraro reference dataset. Assigned labels for each cell are shown at the top of each plot. In general, the heatmap provides a more interpretable diagnostic visualization than the plots of scores and deltas. However, it does require more effort to inspect and may not be feasible for large numbers of labels. It is also difficult to use a heatmap to determine the correctness of assignment for closely related labels. Session information View session info R version 4.0.0 Patched (2020-05-01 r78341) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 18.04.4 LTS Matrix products: default BLAS: /home/luna/Software/R/R-4-0-branch-dev/lib/libRblas.so LAPACK: /home/luna/Software/R/R-4-0-branch-dev/lib/libRlapack.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] parallel stats4 stats graphics grDevices utils datasets [8] methods base other attached packages: [1] scater_1.17.0 ggplot2_3.3.0 [3] SingleCellExperiment_1.11.1 SingleR_1.3.4 [5] SummarizedExperiment_1.19.4 DelayedArray_0.15.1 [7] matrixStats_0.56.0 Biobase_2.49.0 [9] GenomicRanges_1.41.1 GenomeInfoDb_1.25.0 [11] IRanges_2.23.4 S4Vectors_0.27.6 [13] BiocGenerics_0.35.2 BiocStyle_2.17.0 [15] rebook_0.99.0 loaded via a namespace (and not attached): [1] bitops_1.0-6 bit64_0.9-7 [3] RColorBrewer_1.1-2 httr_1.4.1 [5] tools_4.0.0 R6_2.4.1 [7] irlba_2.3.3 vipor_0.4.5 [9] colorspace_1.4-1 DBI_1.1.0 [11] withr_2.2.0 gridExtra_2.3 [13] tidyselect_1.1.0 processx_3.4.2 [15] bit_1.1-15.2 curl_4.3 [17] compiler_4.0.0 graph_1.67.0 [19] BiocNeighbors_1.7.0 labeling_0.3 [21] bookdown_0.19 scales_1.1.1 [23] callr_3.4.3 rappdirs_0.3.1 [25] stringr_1.4.0 digest_0.6.25 [27] rmarkdown_2.1 XVector_0.29.0 [29] pkgconfig_2.0.3 htmltools_0.4.0 [31] highr_0.8 dbplyr_1.4.3 [33] fastmap_1.0.1 rlang_0.4.6 [35] RSQLite_2.2.0 shiny_1.4.0.2 [37] DelayedMatrixStats_1.11.0 farver_2.0.3 [39] BiocParallel_1.23.0 dplyr_0.8.5 [41] RCurl_1.98-1.2 magrittr_1.5 [43] BiocSingular_1.5.0 GenomeInfoDbData_1.2.3 [45] Matrix_1.2-18 ggbeeswarm_0.6.0 [47] munsell_0.5.0 Rcpp_1.0.4.6 [49] viridis_0.5.1 lifecycle_0.2.0 [51] stringi_1.4.6 yaml_2.2.1 [53] zlibbioc_1.35.0 BiocFileCache_1.13.0 [55] AnnotationHub_2.21.0 grid_4.0.0 [57] blob_1.2.1 promises_1.1.0 [59] ExperimentHub_1.15.0 crayon_1.3.4 [61] lattice_0.20-41 CodeDepends_0.6.5 [63] knitr_1.28 ps_1.3.3 [65] pillar_1.4.4 codetools_0.2-16 [67] XML_3.99-0.3 glue_1.4.1 [69] BiocVersion_3.12.0 evaluate_0.14 [71] BiocManager_1.30.10 vctrs_0.3.0 [73] httpuv_1.5.2 gtable_0.3.0 [75] purrr_0.3.4 assertthat_0.2.1 [77] xfun_0.13 rsvd_1.0.3 [79] mime_0.9 xtable_1.8-4 [81] later_1.0.0 viridisLite_0.3.0 [83] pheatmap_1.0.12 tibble_3.0.1 [85] beeswarm_0.2.3 AnnotationDbi_1.51.0 [87] memoise_1.1.0 ellipsis_0.3.1 [89] interactiveDisplayBase_1.27.0 Bibliography "],
["using-multiple-references.html", "Chapter 5 Using multiple references 5.1 Overview 5.2 Using reference-specific labels 5.3 Comparing scores across references 5.4 Using harmonized labels Session info", " Chapter 5 Using multiple references .aaron-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .aaron-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 5.1 Overview In some cases, we may wish to use multiple references for annotation of a test dataset. This yields a more comprehensive set of cell types that are not covered by any individual reference, especially when differences in the resolution are considered. However, it is not trivial due to the presence of batch effects across references (from differences in technology, experimental protocol or the biological system) as well as differences in the annotation vocabulary between investigators. Several strategies are available to combine inferences from multiple references: using reference-specific labels in a combined reference using harmonized labels in a combined reference combining scores across multiple references This chapter discusses the various strengths and weaknesses of each strategy and provides some practical demonstrations of each. Here, we will use the HPCA and BlueprintEncode datasets as our references and (yet another) PBMC dataset as the test. library(TENxPBMCData) pbmc &lt;- TENxPBMCData(&quot;pbmc8k&quot;) library(SingleR) hpca &lt;- HumanPrimaryCellAtlasData(ensembl=TRUE) bpe &lt;- BlueprintEncodeData(ensembl=TRUE) 5.2 Using reference-specific labels In this strategy, each label is defined in the context of its reference dataset. This means that a label - say, “B cell” - in reference dataset X is considered to be different from a “B cell” label in reference dataset Y. Use of reference-specific labels is most appropriate if there are relevant biological differences between the references; for example, if one reference is concerned with healthy tissue while the other reference considers diseased tissue, it can be helpful to distinguish between the same cell type in different biological contexts. We can easily implement this approach by combining the expression matrices together and pasting the reference name onto the corresponding character vector of labels. This modification ensures that the downstream SingleR() call will treat each label-reference combination as a distinct entity. hpca2 &lt;- hpca hpca2$label.main &lt;- paste0(&quot;HPCA.&quot;, hpca2$label.main) bpe2 &lt;- bpe bpe2$label.main &lt;- paste0(&quot;BPE.&quot;, bpe2$label.main) shared &lt;- intersect(rownames(hpca2), rownames(bpe2)) combined &lt;- cbind(hpca2[shared,], bpe2[shared,]) It is then straightforward to perform annotation with the usual methods. com.res1 &lt;- SingleR(pbmc, ref=combined, labels=combined$label.main, assay.type.test=1) table(com.res1$labels) ## ## BPE.B-cells BPE.CD4+ T-cells BPE.CD8+ T-cells BPE.HSC ## 1179 1708 2656 20 ## BPE.Monocytes BPE.NK cells HPCA.HSC_-G-CSF HPCA.Platelets ## 2348 460 1 7 ## HPCA.T_cells ## 2 However, this strategy identifies markers by directly comparing expression values across references, meaning that the marker set is likely to contain genes responsible for uninteresting batch effects. This will increase noise during the calculation of the score in each reference, possibly leading to a loss of precision and a greater risk of technical variation dominating the classification results. The use of reference-specific labels also complicates interpretation of the results as the cell type is always qualified by its reference of origin. 5.3 Comparing scores across references 5.3.1 Combining inferences from individual references Another strategy - and the default approach implemented in SingleR() - involves performing classification separately within each reference, and then collating the results to choose the label with the highest score across references. This is a relatively expedient approach that avoids the need for explicit harmonization while also reducing exposure to reference-specific batch effects. To use this method, we simply pass multiple objects to the ref= and label= argument in SingleR(). The combining strategy is as follows: The function first annotates the test dataset with each reference individually in the same manner as described in Section 1.2. This step is almost equivalent to simply looping over all individual references and running SingleR() on each. For each cell, the function collects its predicted labels across all references. In doing so, it also identifies the union of markers that are upregulated in the predicted label in each reference. The function identifies the overall best-scoring label as the final prediction for that cell. This step involves a recomputation of the scores across the identified marker subset to ensure that these scores are derived from the same set of genes (and are thus comparable across references). The function will then return a DataFrame of combined results for each cell in the test dataset, including the overall label and the reference from which it was assigned. com.res2 &lt;- SingleR(test = pbmc, assay.type.test=1, ref = list(BPE=bpe, HPCA=hpca), labels = list(bpe$label.main, hpca$label.main)) # Check the final label from the combined assignment. table(com.res2$labels) ## ## B_cell B-cells CD4+ T-cells CD8+ T-cells ## 14 1170 1450 2936 ## GMP HSC Monocyte Monocytes ## 1 22 753 1560 ## NK cells NK_cell Platelets Pre-B_cell_CD34- ## 372 10 9 16 ## T_cells ## 68 # Check the &#39;winning&#39; reference for each cell. table(com.res2$reference) ## ## 1 2 ## 7510 871 The main appeal of this approach lies in the fact that it is based on the results of annotation with individual references. This avoids batch effects from comparing expression values across references; it reduces the need for any coordination in the label scheme between references; and simultaneously provides the per-reference annotations in the results. The last feature is particularly useful as it allows for more detailed diagnostics, troubleshooting and further analysis. head(com.res2$orig.results$BPE$labels) ## [1] &quot;B-cells&quot; &quot;Monocytes&quot; &quot;CD8+ T-cells&quot; &quot;CD8+ T-cells&quot; &quot;Monocytes&quot; ## [6] &quot;Monocytes&quot; head(com.res2$orig.results$HPCA$labels) ## [1] &quot;B_cell&quot; &quot;Monocyte&quot; &quot;T_cells&quot; &quot;T_cells&quot; &quot;Monocyte&quot; &quot;Monocyte&quot; The main downside is that it is somewhat suboptimal if there are many labels that are unique to one reference, as markers are not identified with the aim of distinguishing a label in one reference from another label in another reference. The continued lack of consistency in the labels across references also complicates interpretation of the results, though we can overcome this by using harmonized labels as described below. 5.3.2 Combined diagnostics All of the diagnostic plots in SingleR will naturally operate on these combined results. For example, we can create a heatmap of the scores in all of the individual references as well as for the recomputed scores in the combined results (Figure 5.1). Note that scores are only recomputed for the labels predicted in the individual references, so all labels outside of those are simply set to NA - hence the swathes of grey. plotScoreHeatmap(com.res2) Figure 5.1: Heatmaps of assignment scores for each cell in the PBMC test dataset after being assigned to the Blueprint/ENCODE and Human Primary Cell Atlas reference datasets. One heatmap is shown for the recomputed scores and the scores from each individual reference. The annotation at the top of each heatmap represents the final combined prediction for each cell. The deltas for each individual reference can also be plotted with plotDeltaDistribution() (Figure 5.2). No deltas are shown for the recomputed scores as the assumption described in Section 4.3 may not be applicable across the predicted labels from the individual references. For example, if all individual references suggest the same cell type with similar recomputed scores, any delta would be low even though the assignment is highly confident. plotDeltaDistribution(com.res2) Figure 5.2: Distribution of the deltas across cells in the PBMC test dataset for each label in the Blueprint/ENCODE and Human Primary Cell Atlas reference datasets. Each point represents a cell that was assigned to that label in the combined results, colored by whether it was pruned or not in the corresponding individual reference. We can similarly extract marker genes to use in heatmaps as described in Section 4.4. As annotation was performed to each individual reference, we can simply extract the marker genes from the nested DataFrames as shown in Figure 5.3. hpca.markers &lt;- metadata(com.res2$orig.results$HPCA)$de.genes bpe.markers &lt;- metadata(com.res2$orig.results$BPE)$de.genes mono.markers &lt;- unique(unlist(hpca.markers$Monocyte, bpe.markers$Monocytes)) library(scater) plotHeatmap(logNormCounts(pbmc), order_columns_by=list(I(com.res2$labels)), features=mono.markers) Figure 5.3: Heatmap of log-expression values in the PBMC dataset for all marker genes upregulated in monocytes in the Blueprint/ENCODE and Human Primary Cell Atlas reference datasets. Combined labels for each cell are shown at the top. 5.4 Using harmonized labels 5.4.1 Sharing information during marker detection One of the major problems with using multiple references is the presence of study-specific nomenclature. For example, the concept of a B cell may be annotated as B cells in one reference, B_cells in another reference, and then B and B-cell and so on in other references. We can overcome this by using harmonized labels where the same cell type is assigned as the same label across references, simplifying interpretation and ensuring that irrelevant discrepancies in labelling do not intefere with downstream analysis. Many of the SingleR reference datasets already have their labels mapped to the Cell Ontology, which provides a standard vocabulary to refer to the same cell type across diverse datasets. We will describe the utility of Cell Ontology terms in more detail in Chapter 6; at this point, the key idea is that the same term is used for the same conceptual cell type in each reference. To simplify interpretation, we set cell.ont=&quot;nonna&quot; to remove all samples that could not be mapped to the ontology. hpca.ont &lt;- HumanPrimaryCellAtlasData(ensembl=TRUE, cell.ont=&quot;nonna&quot;) bpe.ont &lt;- BlueprintEncodeData(ensembl=TRUE, cell.ont=&quot;nonna&quot;) # Using the same sets of genes: shared &lt;- intersect(rownames(hpca.ont), rownames(bpe.ont)) hpca.ont &lt;- hpca.ont[shared,] bpe.ont &lt;- bpe.ont[shared,] # Showing the top 10 most frequent terms: head(sort(table(hpca.ont$label.ont)), 10) ## ## CL:0002259 CL:0000017 CL:0000049 CL:0000050 CL:0000084 CL:0000127 CL:0000557 ## 1 2 2 2 2 2 2 ## CL:0000798 CL:0000816 CL:0000836 ## 2 2 2 head(sort(table(bpe.ont$label.ont)), 10) ## ## CL:0000451 CL:0000771 CL:0000787 CL:0000815 CL:0000904 CL:0000905 CL:0000907 ## 1 1 1 1 1 1 1 ## CL:0000913 CL:0000972 CL:0000127 ## 1 1 2 The simplest way to take advantage of the standardization in terminology is to use label.ont in place of label.main in the previous section’s SingleR() call. This yields annotations that have follow the same vocabulary regardless of the reference used for assignment. com.res3a &lt;- SingleR(test = pbmc, assay.type.test=1, ref = list(BPE=bpe.ont, HPCA=hpca.ont), labels = list(bpe.ont$label.ont, hpca.ont$label.ont)) table(Label=com.res3a$labels, Reference=com.res3a$reference) ## Reference ## Label 1 2 ## CL:0000037 2 0 ## CL:0000050 6 0 ## CL:0000051 6 0 ## CL:0000233 0 3 ## CL:0000236 0 70 ## CL:0000556 7 0 ## CL:0000557 4 1 ## CL:0000576 1520 548 ## CL:0000623 304 10 ## CL:0000624 734 34 ## CL:0000625 591 89 ## CL:0000786 2 0 ## CL:0000787 270 3 ## CL:0000788 728 12 ## CL:0000798 0 2 ## CL:0000815 78 0 ## CL:0000816 0 21 ## CL:0000837 5 0 ## CL:0000895 0 399 ## CL:0000904 126 867 ## CL:0000905 137 231 ## CL:0000907 729 0 ## CL:0000913 479 5 ## CL:0000955 0 13 ## CL:0000972 101 0 ## CL:0001054 0 244 A more advanced approach is to share information across references during the marker detection stage. This is done by favoring genes the exhibit upregulation consistently in multiple references, which increases the likelihood that those markers will generalize to other datasets. For classic marker detection, we achieve this by calling getClassicMarkers() to obtain markers for use in SingleR(); the same effect can be achieved for test-based methods in scran functions by setting block=. We then use these improved markers by passing them to genes= as described in Section 3.3. In this case, we specify com.markers twice in a list to indicate that we are using them for both of our references. com.markers &lt;- getClassicMarkers( ref = list(BPE=bpe.ont, HPCA=hpca.ont), labels = list(bpe.ont$label.ont, hpca.ont$label.ont)) com.res3b &lt;- SingleR(test = pbmc, assay.type.test=1, ref = list(BPE=bpe.ont, HPCA=hpca.ont), labels = list(bpe.ont$label.ont, hpca.ont$label.ont), genes = list(com.markers, com.markers)) table(Label=com.res3b$labels, Reference=com.res3b$reference) ## Reference ## Label 1 2 ## CL:0000037 4 0 ## CL:0000050 5 0 ## CL:0000051 8 0 ## CL:0000233 0 2 ## CL:0000236 0 106 ## CL:0000556 8 0 ## CL:0000557 1 2 ## CL:0000576 1435 669 ## CL:0000623 306 20 ## CL:0000624 605 90 ## CL:0000625 424 171 ## CL:0000786 3 0 ## CL:0000787 225 2 ## CL:0000788 719 30 ## CL:0000798 0 2 ## CL:0000815 111 0 ## CL:0000816 0 36 ## CL:0000837 5 0 ## CL:0000895 0 410 ## CL:0000904 55 986 ## CL:0000905 108 272 ## CL:0000907 728 0 ## CL:0000913 503 24 ## CL:0000955 0 10 ## CL:0000972 91 0 ## CL:0001054 0 205 It is worth noting that, in the above code, the DE genes are still identified within each reference and then the statistics are merged across references to identify the top markers. This ensures that we do not directly compare expression values across references, which reduces the susceptibility of marker detection to batch effects. The most obvious problem with this approach is that it assumes that harmonized labels are available. This is usually not true and requires some manual mapping of the author-provided labels to a common vocabulary. The mapping process also runs the risk of discarding relevant information about the biological status (e.g., activation status, disease condition) if there is no obvious counterpart for that state in the ontology. 5.4.2 Manual label harmonization The matchReferences() function provides a simple approach for label harmonization between two references. Each reference is used to annotate the other and the probability of mutual assignment between each pair of labels is computed, i.e., for each pair of labels, what is the probability that a cell with one label is assigned the other and vice versa? Probabilities close to 1 in Figure 5.4 indicate there is a 1:1 relation between that pair of labels; on the other hand, an all-zero probability vector indicates that a label is unique to a particular reference. library(SingleR) bp.se &lt;- BlueprintEncodeData() hpca.se &lt;- HumanPrimaryCellAtlasData() matched &lt;- matchReferences(bp.se, hpca.se, bp.se$label.main, hpca.se$label.main) pheatmap::pheatmap(matched, col=viridis::plasma(100)) Figure 5.4: Heatmap of mutual assignment probabilities between the Blueprint/ENCODE reference dataset (labels in rows) and the Human primary cell atlas reference (labels in columns). This function can be used to guide harmonization to enforce a consistent vocabulary between two sets of labels. However, some manual intervention is still required in this process given the ambiguities posed by differences in biological systems and technologies. In the example above, neurons are considered to be unique to each reference while smooth muscle cells in the HPCA data are incorrectly matched to fibroblasts in the Blueprint/ENCODE data. CD4+ and CD8+ T cells are also both assigned to “T cells”, so some decision about the acceptable resolution of the harmonized labels is required here. As an aside, we can also use this function to identify the matching clusters between two independent scRNA-seq analyses. This involves substituting the cluster assignments as proxies for the labels, allowing us to match up clusters and integrate conclusions from multiple datasets without the difficulties of batch correction and reclustering. Session info View session info R version 4.0.0 Patched (2020-05-01 r78341) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 18.04.4 LTS Matrix products: default BLAS: /home/luna/Software/R/R-4-0-branch-dev/lib/libRblas.so LAPACK: /home/luna/Software/R/R-4-0-branch-dev/lib/libRlapack.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] parallel stats4 stats graphics grDevices utils datasets [8] methods base other attached packages: [1] scater_1.17.0 ggplot2_3.3.0 [3] ensembldb_2.13.1 AnnotationFilter_1.13.0 [5] GenomicFeatures_1.41.0 AnnotationDbi_1.51.0 [7] SingleR_1.3.4 TENxPBMCData_1.7.0 [9] HDF5Array_1.17.0 rhdf5_2.33.0 [11] SingleCellExperiment_1.11.1 SummarizedExperiment_1.19.4 [13] DelayedArray_0.15.1 matrixStats_0.56.0 [15] Biobase_2.49.0 GenomicRanges_1.41.1 [17] GenomeInfoDb_1.25.0 IRanges_2.23.4 [19] S4Vectors_0.27.6 BiocGenerics_0.35.2 [21] BiocStyle_2.17.0 rebook_0.99.0 loaded via a namespace (and not attached): [1] ggbeeswarm_0.6.0 colorspace_1.4-1 [3] ellipsis_0.3.1 XVector_0.29.0 [5] BiocNeighbors_1.7.0 farver_2.0.3 [7] bit64_0.9-7 interactiveDisplayBase_1.27.0 [9] codetools_0.2-16 knitr_1.28 [11] Rsamtools_2.5.0 dbplyr_1.4.3 [13] pheatmap_1.0.12 graph_1.67.0 [15] shiny_1.4.0.2 BiocManager_1.30.10 [17] compiler_4.0.0 httr_1.4.1 [19] assertthat_0.2.1 Matrix_1.2-18 [21] fastmap_1.0.1 lazyeval_0.2.2 [23] later_1.0.0 BiocSingular_1.5.0 [25] htmltools_0.4.0 prettyunits_1.1.1 [27] tools_4.0.0 rsvd_1.0.3 [29] gtable_0.3.0 glue_1.4.1 [31] GenomeInfoDbData_1.2.3 dplyr_0.8.5 [33] rappdirs_0.3.1 Rcpp_1.0.4.6 [35] vctrs_0.3.0 Biostrings_2.57.0 [37] ExperimentHub_1.15.0 rtracklayer_1.49.1 [39] DelayedMatrixStats_1.11.0 xfun_0.13 [41] stringr_1.4.0 ps_1.3.3 [43] beachmat_2.5.0 mime_0.9 [45] lifecycle_0.2.0 irlba_2.3.3 [47] XML_3.99-0.3 AnnotationHub_2.21.0 [49] zlibbioc_1.35.0 scales_1.1.1 [51] hms_0.5.3 promises_1.1.0 [53] ProtGenerics_1.21.0 RColorBrewer_1.1-2 [55] yaml_2.2.1 curl_4.3 [57] memoise_1.1.0 gridExtra_2.3 [59] biomaRt_2.45.0 stringi_1.4.6 [61] RSQLite_2.2.0 highr_0.8 [63] BiocVersion_3.12.0 BiocParallel_1.23.0 [65] rlang_0.4.6 pkgconfig_2.0.3 [67] bitops_1.0-6 evaluate_0.14 [69] lattice_0.20-41 purrr_0.3.4 [71] Rhdf5lib_1.11.0 labeling_0.3 [73] GenomicAlignments_1.25.0 CodeDepends_0.6.5 [75] bit_1.1-15.2 processx_3.4.2 [77] tidyselect_1.1.0 magrittr_1.5 [79] bookdown_0.19 R6_2.4.1 [81] DBI_1.1.0 withr_2.2.0 [83] pillar_1.4.4 RCurl_1.98-1.2 [85] tibble_3.0.1 crayon_1.3.4 [87] BiocFileCache_1.13.0 rmarkdown_2.1 [89] viridis_0.5.1 progress_1.2.2 [91] grid_4.0.0 blob_1.2.1 [93] callr_3.4.3 digest_0.6.25 [95] xtable_1.8-4 httpuv_1.5.2 [97] openssl_1.4.1 munsell_0.5.0 [99] beeswarm_0.2.3 viridisLite_0.3.0 [101] vipor_0.4.5 askpass_1.1 "],
["exploiting-the-cell-ontology.html", "Chapter 6 Exploiting the cell ontology 6.1 Motivation 6.2 Basic manipulation 6.3 Adjusting resolution Session information", " Chapter 6 Exploiting the cell ontology .aaron-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .aaron-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 6.1 Motivation As previously discussed in Section 5.4, SingleR maps the labels in its references to the Cell Ontology. The most obvious advantage of doing this is to provide a standardized vocabulary with which to describe cell types, thus facilitating integrated analyses with multiple references. However, another useful feature of the Cell Ontology is its hierarchical organization of terms, allowing us to adjust cell type annotations to the desired resolution. This represents a more dynamic alternative to the static label.main and label.fine options in each reference. 6.2 Basic manipulation We use the ontoProc package to load in the Cell Ontology. This produces an ontology_index object (from the ontologyIndex package) that we can query for various pieces of information. # TODO: wrap in utility function. library(ontoProc) bfc &lt;- BiocFileCache::BiocFileCache(ask=FALSE) path &lt;- BiocFileCache::bfcrpath(bfc, &quot;http://purl.obolibrary.org/obo/cl.obo&quot;) cl &lt;- get_ontology(path, extract_tags=&quot;everything&quot;) cl ## Ontology with 2236 terms ## ## format-version: 1.2 ## data-version: cl/2020-05-21/cl-simple.owl ## ontology: cl/cl-simple ## ## Properties: ## id: character ## name: character ## parents: list ## children: list ## ancestors: list ## obsolete: logical ## alt_id: list ## comment: character ## consider: list ## created_by: character ## creation_date: character ## data-version: list ## def: character ## develops_from: list ## format-version: list ## holds_over_chain: list ## is_a: list ## is_transitive: list ## namespace: list ## ontology: list ## property_value: list ## remark: list ## replaced_by: list ## subset: list ## subsetdef: list ## synonym: list ## synonymtypedef: list ## transitive_over: list ## xref: list ## Roots: ## CL:0000000 - cell ## BFO:0000050 - NA ## develops_from - develops_from The most immediate use of this object lies in mapping ontology terms to their plain-English descriptions. We can use this to translate annotations produced by SingleR() from the label.ont labels into a more interpretable form. We demonstrate this approach using SingleR’s collection of mouse RNA-seq references (Aran et al. 2019). head(cl$name) # short name ## CL:0000000 CL:0000001 ## &quot;cell&quot; &quot;primary cultured cell&quot; ## CL:0000002 CL:0000003 ## &quot;obsolete immortal cell line cell&quot; &quot;native cell&quot; ## CL:0000004 CL:0000005 ## &quot;obsolete cell by organism&quot; &quot;fibroblast neural crest derived&quot; head(cl$def) # longer definition ## CL:0000000 ## &quot;\\&quot;A material entity of anatomical origin (part of or deriving from an organism) that has as its parts a maximally connected cell compartment surrounded by a plasma membrane.\\&quot; [CARO:mah]&quot; ## CL:0000001 ## &quot;\\&quot;A cultured cell that is freshly isolated from a organismal source, or derives in culture from such a cell prior to the culture being passaged.\\&quot; [ReO:mhb]&quot; ## CL:0000002 ## &quot;\\&quot;OBSOLETE: A cell line cell that is expected to be capable of an unlimited number of divisions, and is thus able to support indefinite growth/propagation in vitro as part of a immortal cell line.\\&quot; [ReO:mhb]&quot; ## CL:0000003 ## &quot;\\&quot;A cell that is found in a natural setting, which includes multicellular organism cells &#39;in vivo&#39; (i.e. part of an organism), and unicellular organisms &#39;in environment&#39; (i.e. part of a natural environment).\\&quot; [CARO:mah]&quot; ## CL:0000004 ## &quot;\\&quot;OBSOLETE: A classification of cells by the organisms within which they are contained.\\&quot; [FB:ma]&quot; ## CL:0000005 ## &quot;\\&quot;Any fibroblast that is deriived from the neural crest.\\&quot; [https://orcid.org/0000-0001-5208-3432]&quot; library(SingleR) ref &lt;- MouseRNAseqData(cell.ont=&quot;nonna&quot;) translated &lt;- cl$name[ref$label.ont] head(translated) ## &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## NA NA NA NA NA NA Another interesting application involves examining the relationship between different terms. The ontology itself is a directed acyclic graph, so we can can convert it into graph object for advanced queries using the igraph package. Each edge represents an “is a” relationship where each vertex represents a specialized case of the concept of the parent node. # TODO: wrap in utility function. parents &lt;- cl$parents self &lt;- rep(names(parents), lengths(parents)) library(igraph) g &lt;- make_graph(rbind(unlist(parents), self)) g ## IGRAPH 045f37f DN-- 2234 3141 -- ## + attr: name (v/c) ## + edges from 045f37f (vertex names): ## [1] CL:0000010-&gt;CL:0000001 CL:0000000-&gt;CL:0000003 CL:0000057-&gt;CL:0000005 ## [4] CL:0000101-&gt;CL:0000006 CL:0000197-&gt;CL:0000006 CL:0002321-&gt;CL:0000007 ## [7] CL:0000333-&gt;CL:0000008 CL:0000578-&gt;CL:0000010 CL:0000333-&gt;CL:0000011 ## [10] CL:0000034-&gt;CL:0000014 CL:0000039-&gt;CL:0000014 CL:0000586-&gt;CL:0000015 ## [13] CL:0000014-&gt;CL:0000016 CL:0000015-&gt;CL:0000016 CL:0000015-&gt;CL:0000017 ## [16] CL:0000015-&gt;CL:0000018 CL:0000413-&gt;CL:0000018 CL:0000408-&gt;CL:0000019 ## [19] CL:0000015-&gt;CL:0000020 CL:0000586-&gt;CL:0000021 CL:0000014-&gt;CL:0000022 ## [22] CL:0000021-&gt;CL:0000022 CL:0000021-&gt;CL:0000023 CL:0000021-&gt;CL:0000024 ## + ... omitted several edges One query involves identifying all descendents of a particular term of interest. This can be useful when searching for a cell type in the presence of variable annotation resolution; for example, a search for “epithelial cell” can be configured to pick up all child terms such as “endothelial cell” and “ependymal cell”. term &lt;- &quot;CL:0000624&quot; cl$name[term] ## CL:0000624 ## &quot;CD4-positive, alpha-beta T cell&quot; all.kids &lt;- names(subcomponent(g, term)) head(cl$name[all.kids]) ## CL:0000624 ## &quot;CD4-positive, alpha-beta T cell&quot; ## CL:0000492 ## &quot;CD4-positive helper T cell&quot; ## CL:0001051 ## &quot;CD4-positive, CXCR3-negative, CCR6-negative, alpha-beta T cell&quot; ## CL:0000791 ## &quot;mature alpha-beta T cell&quot; ## CL:0000792 ## &quot;CD4-positive, CD25-positive, alpha-beta regulatory T cell&quot; ## CL:0000793 ## &quot;CD4-positive, alpha-beta intraepithelial T cell&quot; Alternatively, we might be interested in the last common ancestor (LCA) for a set of terms. This is the furthest term - or, in some cases, multiple terms - from the root of the ontology that is also an ancestor of all of the terms of interest. We will use this LCA concept in the next section to adjust resolution across multiple references. terms &lt;- c(&quot;CL:0000624&quot;, &quot;CL:0000785&quot;, &quot;CL:0000623&quot;) cl$name[terms] ## CL:0000624 CL:0000785 ## &quot;CD4-positive, alpha-beta T cell&quot; &quot;mature B cell&quot; ## CL:0000623 ## &quot;natural killer cell&quot; # TODO: god, put this in a function somewhere. all.ancestors &lt;- lapply(terms, subcomponent, graph=g, mode=&quot;in&quot;) all.ancestors &lt;- lapply(all.ancestors, names) common.ancestors &lt;- Reduce(intersect, all.ancestors) ancestors.of.ancestors &lt;- lapply(common.ancestors, subcomponent, graph=g, mode=&quot;in&quot;) ancestors.of.ancestors &lt;- lapply(ancestors.of.ancestors, names) ancestors.of.ancestors &lt;- mapply(setdiff, ancestors.of.ancestors, common.ancestors) latest.common.ancestors &lt;- setdiff(common.ancestors, unlist(ancestors.of.ancestors)) cl$name[latest.common.ancestors] ## CL:0000542 ## &quot;lymphocyte&quot; 6.3 Adjusting resolution We can use the ontology graph to adjust the resolution of the reference labels by rolling up overly-specific terms to their LCA. The findCommonAncestors() utility takes a set of terms and returns a list of potential LCAs for various subsets of those terms. Users can inspect this list to identify LCAs at the desired resolution and then map their descendent terms to those LCAs. findCommonAncestors &lt;- function(..., g, remove.self=TRUE, names=NULL) { terms &lt;- list(...) if (is.null(names(terms))) { names(terms) &lt;- sprintf(&quot;set%i&quot;, seq_along(terms)) } all.terms &lt;- unique(unlist(terms)) all.ancestors &lt;- lapply(all.terms, subcomponent, graph=g, mode=&quot;in&quot;) all.ancestors &lt;- lapply(all.ancestors, names) by.ancestor &lt;- split( rep(all.terms, lengths(all.ancestors)), unlist(all.ancestors) ) # Removing ancestor nodes with the same count as its children. available &lt;- names(by.ancestor) for (i in available) { if (!i %in% names(by.ancestor)) { next } counts &lt;- lengths(by.ancestor) cur.ancestors &lt;- subcomponent(g, i, mode=&quot;in&quot;) cur.ancestors &lt;- setdiff(names(cur.ancestors), i) drop &lt;- cur.ancestors[counts[i]==counts[cur.ancestors]] by.ancestor &lt;- by.ancestor[!names(by.ancestor) %in% drop] } if (remove.self) { by.ancestor &lt;- by.ancestor[lengths(by.ancestor) &gt; 1L] } by.ancestor &lt;- by.ancestor[order(lengths(by.ancestor))] # most specific terms first. # Decorating the output. for (i in names(by.ancestor)) { current &lt;- by.ancestor[[i]] df &lt;- DataFrame(row.names=current) curout &lt;- list() if (!is.null(names)) { curout$name &lt;- unname(names[i]) df$name &lt;- names[current] } presence &lt;- list() for (b in names(terms)) { presence[[b]] &lt;- current %in% terms[[b]] } df &lt;- cbind(df, do.call(DataFrame, presence)) curout$descendents &lt;- df by.ancestor[[i]] &lt;- curout } by.ancestor } lca &lt;- findCommonAncestors(ref$label.ont, g=g, names=cl$name) head(lca) ## $`CL:0000081` ## $`CL:0000081`$name ## [1] &quot;blood cell&quot; ## ## $`CL:0000081`$descendents ## DataFrame with 2 rows and 2 columns ## name set1 ## &lt;character&gt; &lt;logical&gt; ## CL:0000232 erythrocyte TRUE ## CL:0000094 granulocyte TRUE ## ## ## $`CL:0000126` ## $`CL:0000126`$name ## [1] &quot;macroglial cell&quot; ## ## $`CL:0000126`$descendents ## DataFrame with 2 rows and 2 columns ## name set1 ## &lt;character&gt; &lt;logical&gt; ## CL:0000127 astrocyte TRUE ## CL:0000128 oligodendrocyte TRUE ## ## ## $`CL:0000393` ## $`CL:0000393`$name ## [1] &quot;electrically responsive cell&quot; ## ## $`CL:0000393`$descendents ## DataFrame with 2 rows and 2 columns ## name set1 ## &lt;character&gt; &lt;logical&gt; ## CL:0000540 neuron TRUE ## CL:0000746 cardiac muscle cell TRUE ## ## ## $`CL:0002320` ## $`CL:0002320`$name ## [1] &quot;connective tissue cell&quot; ## ## $`CL:0002320`$descendents ## DataFrame with 2 rows and 2 columns ## name set1 ## &lt;character&gt; &lt;logical&gt; ## CL:0000136 fat cell TRUE ## CL:0000057 fibroblast TRUE ## ## ## $`CL:0011115` ## $`CL:0011115`$name ## [1] &quot;precursor cell&quot; ## ## $`CL:0011115`$descendents ## DataFrame with 2 rows and 2 columns ## name set1 ## &lt;character&gt; &lt;logical&gt; ## CL:0000047 neuronal stem cell TRUE ## CL:0000576 monocyte TRUE ## ## ## $`CL:0000066` ## $`CL:0000066`$name ## [1] &quot;epithelial cell&quot; ## ## $`CL:0000066`$descendents ## DataFrame with 3 rows and 2 columns ## name set1 ## &lt;character&gt; &lt;logical&gt; ## CL:0000115 endothelial cell TRUE ## CL:0000182 hepatocyte TRUE ## CL:0000065 ependymal cell TRUE We can also use this function to synchronize multiple sets of terms to the same resolution. Here, we consider the ImmGen dataset (Heng et al. 2008), which provides highly resolved annotation of immune cell types. The findCommonAncestors() function specifies the origins of the descendents for each LCA, allowing us to focus on LCAs that have representatives in both sets of terms. ref2 &lt;- ImmGenData(cell.ont=&quot;nonna&quot;) lca2 &lt;- findCommonAncestors(MouseRNA=ref$label.ont, ImmGen=ref2$label.ont, g=g, names=cl$name) head(lca2) ## $`CL:0000126` ## $`CL:0000126`$name ## [1] &quot;macroglial cell&quot; ## ## $`CL:0000126`$descendents ## DataFrame with 2 rows and 3 columns ## name MouseRNA ImmGen ## &lt;character&gt; &lt;logical&gt; &lt;logical&gt; ## CL:0000127 astrocyte TRUE FALSE ## CL:0000128 oligodendrocyte TRUE FALSE ## ## ## $`CL:0000393` ## $`CL:0000393`$name ## [1] &quot;electrically responsive cell&quot; ## ## $`CL:0000393`$descendents ## DataFrame with 2 rows and 3 columns ## name MouseRNA ImmGen ## &lt;character&gt; &lt;logical&gt; &lt;logical&gt; ## CL:0000540 neuron TRUE FALSE ## CL:0000746 cardiac muscle cell TRUE FALSE ## ## ## $`CL:0000623` ## $`CL:0000623`$name ## [1] &quot;natural killer cell&quot; ## ## $`CL:0000623`$descendents ## DataFrame with 2 rows and 3 columns ## name MouseRNA ImmGen ## &lt;character&gt; &lt;logical&gt; &lt;logical&gt; ## CL:0000623 natural killer cell TRUE TRUE ## CL:0002438 NK1.1-positive natural killer cell FALSE TRUE ## ## ## $`CL:0000813` ## $`CL:0000813`$name ## [1] &quot;memory T cell&quot; ## ## $`CL:0000813`$descendents ## DataFrame with 2 rows and 3 columns ## name MouseRNA ImmGen ## &lt;character&gt; &lt;logical&gt; &lt;logical&gt; ## CL:0000897 CD4-positive, alpha-beta memory T cell FALSE TRUE ## CL:0000909 CD8-positive, alpha-beta memory T cell FALSE TRUE ## ## ## $`CL:0000815` ## $`CL:0000815`$name ## [1] &quot;regulatory T cell&quot; ## ## $`CL:0000815`$descendents ## DataFrame with 2 rows and 3 columns ## name MouseRNA ## &lt;character&gt; &lt;logical&gt; ## CL:0000792 CD4-positive, CD25-positive, alpha-beta regulatory T cell FALSE ## CL:0000815 regulatory T cell FALSE ## ImmGen ## &lt;logical&gt; ## CL:0000792 TRUE ## CL:0000815 TRUE ## ## ## $`CL:0000819` ## $`CL:0000819`$name ## [1] &quot;B-1 B cell&quot; ## ## $`CL:0000819`$descendents ## DataFrame with 2 rows and 3 columns ## name MouseRNA ImmGen ## &lt;character&gt; &lt;logical&gt; &lt;logical&gt; ## CL:0000820 B-1a B cell FALSE TRUE ## CL:0000821 B-1b B cell FALSE TRUE For example, we might notice that the mouse RNA-seq reference only has a single “T cell” term. To synchronize resolution across references, we would need to roll up all of the ImmGen’s finely resolved subsets into that LCA as shown below. Of course, this results in some loss of precision and information; whether this is an acceptable price for simpler interpretation is a decision that is left to the user. children &lt;- lca2$`CL:0000084`$descendents children ## DataFrame with 35 rows and 3 columns ## name MouseRNA ## &lt;character&gt; &lt;logical&gt; ## CL:0000084 T cell TRUE ## CL:0002427 resting double-positive thymocyte FALSE ## CL:0000809 double-positive, alpha-beta thymocyte FALSE ## CL:0002429 CD69-positive double-positive thymocyte FALSE ## CL:0000624 CD4-positive, alpha-beta T cell FALSE ## ... ... ... ## CL:0002415 immature Vgamma1.1-positive, Vdelta6.3-positive thymocyte FALSE ## CL:0002411 Vgamma1.1-positive, Vdelta6.3-negative thymocyte FALSE ## CL:0002416 mature Vgamma1.1-positive, Vdelta6.3-positive thymocyte FALSE ## CL:0002407 mature Vgamma2-positive thymocyte FALSE ## CL:0000815 regulatory T cell FALSE ## ImmGen ## &lt;logical&gt; ## CL:0000084 TRUE ## CL:0002427 TRUE ## CL:0000809 TRUE ## CL:0002429 TRUE ## CL:0000624 TRUE ## ... ... ## CL:0002415 TRUE ## CL:0002411 TRUE ## CL:0002416 TRUE ## CL:0002407 TRUE ## CL:0000815 TRUE # Synchronization: synced.mm &lt;- ref$label.ont synced.mm[synced.mm %in% rownames(children)] &lt;- &quot;CL:0000084&quot; synced.ig &lt;- ref2$label.ont synced.ig[synced.ig %in% rownames(children)] &lt;- &quot;CL:0000084&quot; Session information View session info R version 4.0.0 Patched (2020-05-01 r78341) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 18.04.4 LTS Matrix products: default BLAS: /home/luna/Software/R/R-4-0-branch-dev/lib/libRblas.so LAPACK: /home/luna/Software/R/R-4-0-branch-dev/lib/libRlapack.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 parallel stats graphics grDevices utils datasets [8] methods base other attached packages: [1] igraph_1.2.5 SingleR_1.3.4 [3] SummarizedExperiment_1.19.4 DelayedArray_0.15.1 [5] matrixStats_0.56.0 Biobase_2.49.0 [7] GenomicRanges_1.41.1 GenomeInfoDb_1.25.0 [9] IRanges_2.23.5 S4Vectors_0.27.6 [11] BiocGenerics_0.35.2 ontoProc_1.9.2 [13] ontologyIndex_2.5 BiocStyle_2.17.0 [15] rebook_0.99.0 loaded via a namespace (and not attached): [1] httr_1.4.1 BiocSingular_1.5.0 [3] AnnotationHub_2.21.0 bit64_0.9-7 [5] DelayedMatrixStats_1.11.0 ontologyPlot_1.4 [7] paintmap_1.0 shiny_1.4.0.2 [9] assertthat_0.2.1 interactiveDisplayBase_1.27.2 [11] BiocFileCache_1.13.0 BiocManager_1.30.10 [13] blob_1.2.1 GenomeInfoDbData_1.2.3 [15] yaml_2.2.1 BiocVersion_3.12.0 [17] pillar_1.4.4 RSQLite_2.2.0 [19] lattice_0.20-41 glue_1.4.1 [21] digest_0.6.25 promises_1.1.0 [23] XVector_0.29.1 htmltools_0.4.0 [25] httpuv_1.5.2 Matrix_1.2-18 [27] XML_3.99-0.3 pkgconfig_2.0.3 [29] bookdown_0.19 zlibbioc_1.35.0 [31] purrr_0.3.4 xtable_1.8-4 [33] processx_3.4.2 later_1.0.0 [35] BiocParallel_1.23.0 tibble_3.0.1 [37] ellipsis_0.3.1 magrittr_1.5 [39] crayon_1.3.4 CodeDepends_0.6.5 [41] mime_0.9 memoise_1.1.0 [43] evaluate_0.14 ps_1.3.3 [45] graph_1.67.0 tools_4.0.0 [47] lifecycle_0.2.0 stringr_1.4.0 [49] irlba_2.3.3 AnnotationDbi_1.51.0 [51] callr_3.4.3 compiler_4.0.0 [53] rsvd_1.0.3 rlang_0.4.6 [55] grid_4.0.0 RCurl_1.98-1.2 [57] BiocNeighbors_1.7.0 rappdirs_0.3.1 [59] bitops_1.0-6 rmarkdown_2.1 [61] ExperimentHub_1.15.0 codetools_0.2-16 [63] curl_4.3 DBI_1.1.0 [65] R6_2.4.1 knitr_1.28 [67] dplyr_0.8.5 fastmap_1.0.1 [69] bit_1.1-15.2 Rgraphviz_2.33.0 [71] stringi_1.4.6 Rcpp_1.0.4.6 [73] vctrs_0.3.0 dbplyr_1.4.3 [75] tidyselect_1.1.0 xfun_0.14 Bibliography "],
["advanced-options.html", "Chapter 7 Advanced options 7.1 Preconstructed indices 7.2 Parallelization 7.3 Approximate algorithms Session information", " Chapter 7 Advanced options .aaron-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .aaron-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 7.1 Preconstructed indices Advanced users can split the SingleR() workflow into two separate training and classification steps. This means that training (e.g., marker detection, assembling of nearest-neighbor indices) only needs to be performed once for any reference. The resulting data structure can then be re-used across multiple classifications with different test datasets, provided the gene annotation in the test dataset is identical to or a superset of the genes in the training set. To illustrate, we will consider the DICE reference dataset (Schmiedel et al. 2018). library(SingleR) dice &lt;- DatabaseImmuneCellExpressionData(ensembl=TRUE) dice ## class: SummarizedExperiment ## dim: 29914 1561 ## metadata(0): ## assays(1): logcounts ## rownames(29914): ENSG00000121410 ENSG00000268895 ... ENSG00000159840 ## ENSG00000074755 ## rowData names(0): ## colnames(1561): TPM_1 TPM_2 ... TPM_101 TPM_102 ## colData names(3): label.main label.fine label.ont table(dice$label.fine) ## ## B cells, naive Monocytes, CD14+ ## 106 106 ## Monocytes, CD16+ NK cells ## 105 105 ## T cells, CD4+, memory TREG T cells, CD4+, naive ## 104 103 ## T cells, CD4+, naive TREG T cells, CD4+, naive, stimulated ## 104 102 ## T cells, CD4+, TFH T cells, CD4+, Th1 ## 104 104 ## T cells, CD4+, Th1_17 T cells, CD4+, Th17 ## 104 104 ## T cells, CD4+, Th2 T cells, CD8+, naive ## 104 104 ## T cells, CD8+, naive, stimulated ## 102 Let’s say we want to use the DICE reference to annotate the PBMC dataset from Chapter 1. library(TENxPBMCData) sce &lt;- TENxPBMCData(&quot;pbmc3k&quot;) We use the trainSingleR() function to do all the necessary calculations that are independent of the test dataset. (Almost; see comments below about common.) This yields a list of various components that contains all identified marker genes and precomputed rank indices to be used in the score calculation. We can also turn on aggregation with aggr.ref=TRUE (Section @ref(pseudo-bulk aggregation)) to further reduce computational work. common &lt;- intersect(rownames(sce), rownames(dice)) set.seed(2000) trained &lt;- trainSingleR(dice[common,], labels=dice$label.fine, aggr.ref=TRUE) We then use the trained object to annotate our dataset of interest through the classifySingleR() function. As we can see, this yields exactly the same result as applying SingleR() directly. The advantage here is that trained can be re-used for multiple classifySingleR() calls - possibly on different datasets - without having to repeat unnecessary steps when the reference is unchanged. pred &lt;- classifySingleR(sce, trained, assay.type=1) table(pred$labels) ## ## B cells, naive Monocytes, CD14+ ## 346 514 ## Monocytes, CD16+ NK cells ## 187 325 ## T cells, CD4+, memory TREG T cells, CD4+, naive ## 163 97 ## T cells, CD4+, naive TREG T cells, CD4+, TFH ## 41 456 ## T cells, CD4+, Th1 T cells, CD4+, Th1_17 ## 180 73 ## T cells, CD4+, Th17 T cells, CD4+, Th2 ## 60 46 ## T cells, CD8+, naive ## 212 # Comparing to the direct approach. set.seed(2000) direct &lt;- SingleR(sce, ref=dice, labels=dice$label.fine, assay.type.test=1, aggr.ref=TRUE) identical(pred$labels, direct$labels) ## [1] TRUE The big caveat is that the universe of genes in the test dataset must be a superset of that the reference. This is the reason behind the intersection to common genes and the subsequent subsetting of dice. Practical use of preconstructed indices is best combined with some prior information about the gene-level annotation; for example, we might know that we always use a particular version of the Ensembl gene models, so we would filter out any genes in the reference dataset that are not in our test datasets. 7.2 Parallelization Parallelization is an obvious approach to increasing annotation throughput. This is done using the framework in the BiocParallel package, which provides several options for parallelization depending on the available hardware. On POSIX-compliant systems (i.e., Linux and MacOS), the simplest method is to use forking by passing MulticoreParam() to the BPPARAM= argument: library(BiocParallel) pred2a &lt;- SingleR(sce, ref=dice, assay.type.test=1, labels=dice$label.fine, BPPARAM=MulticoreParam(8)) # 8 CPUs. Alternatively, one can use separate processes with SnowParam(), which is slower but can be used on all systems - including Windows, our old nemesis. pred2b &lt;- SingleR(sce, ref=dice, assay.type.test=1, labels=dice$label.fine, BPPARAM=SnowParam(8)) identical(pred$labels, pred2b$labels) ## [1] FALSE When working on a cluster, passing BatchtoolsParam() to SingleR() allows us to seamlessly interface with various job schedulers like SLURM, LSF and so on. This permits heavy-duty parallelization across hundreds of CPUs for highly intensive jobs, though often some configuration is required - see the vignette for more details. 7.3 Approximate algorithms It is possible to sacrifice accuracy to squeeze more speed out of SingleR. The most obvious approach is to simply turn off the fine-tuning with fine.tune=FALSE, which avoids the time-consuming fine-tuning iterations. When the reference labels are well-separated, this is probably an acceptable trade-off. pred3a &lt;- SingleR(sce, ref=dice, assay.type.test=1, labels=dice$label.main, fine.tune=FALSE) table(pred3a$labels) ## ## B cells Monocytes NK cells T cells, CD4+ T cells, CD8+ ## 348 705 357 950 340 Another approximation is based on the fact that the initial score calculation is done using a nearest-neighbors search. By default, this is an exact seach but we can switch to an approximate algorithm via the BNPARAM= argument. In the example below, we use the Annoy algorithm via the BiocNeighbors framework, which yields mostly similar results. (Note, though, that the Annoy method does involve a considerable amount of overhead, so for small jobs it will actually be slower than the exact search.) library(BiocNeighbors) pred3b &lt;- SingleR(sce, ref=dice, assay.type.test=1, labels=dice$label.main, fine.tune=FALSE, # for comparison with pred3a. BNPARAM=AnnoyParam()) table(pred3a$labels, pred3b$labels) ## ## B cells Monocytes NK cells T cells, CD4+ T cells, CD8+ ## B cells 348 0 0 0 0 ## Monocytes 0 705 0 0 0 ## NK cells 0 0 357 0 0 ## T cells, CD4+ 0 0 0 950 0 ## T cells, CD8+ 0 0 0 0 340 Session information View session info R version 4.0.0 Patched (2020-05-01 r78341) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 18.04.4 LTS Matrix products: default BLAS: /home/luna/Software/R/R-4-0-branch-dev/lib/libRblas.so LAPACK: /home/luna/Software/R/R-4-0-branch-dev/lib/libRlapack.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] parallel stats4 stats graphics grDevices utils datasets [8] methods base other attached packages: [1] BiocNeighbors_1.7.0 BiocParallel_1.23.0 [3] TENxPBMCData_1.7.0 HDF5Array_1.17.0 [5] rhdf5_2.33.0 SingleCellExperiment_1.11.1 [7] ensembldb_2.13.1 AnnotationFilter_1.13.0 [9] GenomicFeatures_1.41.0 AnnotationDbi_1.51.0 [11] SingleR_1.3.4 SummarizedExperiment_1.19.4 [13] DelayedArray_0.15.1 matrixStats_0.56.0 [15] Biobase_2.49.0 GenomicRanges_1.41.1 [17] GenomeInfoDb_1.25.0 IRanges_2.23.4 [19] S4Vectors_0.27.6 BiocGenerics_0.35.2 [21] BiocStyle_2.17.0 rebook_0.99.0 loaded via a namespace (and not attached): [1] ProtGenerics_1.21.0 bitops_1.0-6 [3] bit64_0.9-7 progress_1.2.2 [5] httr_1.4.1 tools_4.0.0 [7] R6_2.4.1 irlba_2.3.3 [9] lazyeval_0.2.2 DBI_1.1.0 [11] prettyunits_1.1.1 tidyselect_1.1.0 [13] processx_3.4.2 bit_1.1-15.2 [15] curl_4.3 compiler_4.0.0 [17] graph_1.67.0 rtracklayer_1.49.1 [19] bookdown_0.19 askpass_1.1 [21] callr_3.4.3 rappdirs_0.3.1 [23] Rsamtools_2.5.0 stringr_1.4.0 [25] digest_0.6.25 rmarkdown_2.1 [27] XVector_0.29.0 pkgconfig_2.0.3 [29] htmltools_0.4.0 dbplyr_1.4.3 [31] fastmap_1.0.1 rlang_0.4.6 [33] RSQLite_2.2.0 shiny_1.4.0.2 [35] DelayedMatrixStats_1.11.0 dplyr_0.8.5 [37] RCurl_1.98-1.2 magrittr_1.5 [39] BiocSingular_1.5.0 GenomeInfoDbData_1.2.3 [41] Matrix_1.2-18 Rhdf5lib_1.11.0 [43] Rcpp_1.0.4.6 lifecycle_0.2.0 [45] stringi_1.4.6 yaml_2.2.1 [47] zlibbioc_1.35.0 BiocFileCache_1.13.0 [49] AnnotationHub_2.21.0 grid_4.0.0 [51] blob_1.2.1 promises_1.1.0 [53] ExperimentHub_1.15.0 crayon_1.3.4 [55] lattice_0.20-41 Biostrings_2.57.0 [57] hms_0.5.3 CodeDepends_0.6.5 [59] knitr_1.28 ps_1.3.3 [61] pillar_1.4.4 codetools_0.2-16 [63] biomaRt_2.45.0 XML_3.99-0.3 [65] glue_1.4.1 BiocVersion_3.12.0 [67] evaluate_0.14 BiocManager_1.30.10 [69] vctrs_0.3.0 httpuv_1.5.2 [71] openssl_1.4.1 purrr_0.3.4 [73] assertthat_0.2.1 xfun_0.13 [75] rsvd_1.0.3 mime_0.9 [77] xtable_1.8-4 later_1.0.0 [79] snow_0.4-3 tibble_3.0.1 [81] GenomicAlignments_1.25.0 memoise_1.1.0 [83] ellipsis_0.3.1 interactiveDisplayBase_1.27.0 Bibliography "],
["cross-annotating-pancreas.html", "Chapter 8 Cross-annotating pancreas 8.1 Loading the data 8.2 Applying the annotation 8.3 Diagnostics Session information", " Chapter 8 Cross-annotating pancreas .aaron-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .aaron-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 8.1 Loading the data We load the Muraro et al. (2016) dataset as our reference, removing unlabelled cells or cells without a clear label. We also need to compute log-expression values for use in SingleR(). library(scRNAseq) sceM &lt;- MuraroPancreasData() sceM &lt;- sceM[,!is.na(sceM$label) &amp; sceM$label!=&quot;unclear&quot;] library(scater) sceM &lt;- logNormCounts(sceM) # Examining the distribution of labels in this reference. table(sceM$label) ## ## acinar alpha beta delta duct endothelial ## 219 812 448 193 245 21 ## epsilon mesenchymal pp ## 3 80 101 We load the Grun et al. (2016) dataset as our test, applying some basic quality control to remove low-quality cells in some of the batches (see here for details). Technically speaking, this does not need log-expression values but we compute them anyway for convenience. sceG &lt;- GrunPancreasData() sceG &lt;- addPerCellQC(sceG) qc &lt;- quickPerCellQC(colData(sceG), percent_subsets=&quot;altexps_ERCC_percent&quot;, batch=sceG$donor, subset=sceG$donor %in% c(&quot;D17&quot;, &quot;D7&quot;, &quot;D2&quot;)) sceG &lt;- sceG[,!qc$discard] sceG &lt;- logNormCounts(sceG) ncol(sceG) ## [1] 1064 8.2 Applying the annotation We apply SingleR() with Wilcoxon rank sum test-based marker detection to annotate the Grun dataset. library(SingleR) pred.grun &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, de.method=&quot;wilcox&quot;) We examine the distribution of predicted labels: table(pred.grun$labels) ## ## acinar alpha beta delta duct endothelial ## 277 203 181 50 306 5 ## epsilon mesenchymal pp ## 1 22 19 8.3 Diagnostics Session information prettySessionInfo() View session info R version 4.0.0 Patched (2020-05-01 r78341) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 18.04.4 LTS Matrix products: default BLAS: /home/luna/Software/R/R-4-0-branch-dev/lib/libRblas.so LAPACK: /home/luna/Software/R/R-4-0-branch-dev/lib/libRlapack.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] parallel stats4 stats graphics grDevices utils datasets [8] methods base other attached packages: [1] SingleR_1.3.4 scater_1.17.0 [3] ggplot2_3.3.0 scRNAseq_2.3.0 [5] SingleCellExperiment_1.11.1 SummarizedExperiment_1.19.4 [7] DelayedArray_0.15.1 matrixStats_0.56.0 [9] Biobase_2.49.0 GenomicRanges_1.41.1 [11] GenomeInfoDb_1.25.0 IRanges_2.23.4 [13] S4Vectors_0.27.6 BiocGenerics_0.35.2 [15] BiocStyle_2.17.0 rebook_0.99.0 loaded via a namespace (and not attached): [1] bitops_1.0-6 bit64_0.9-7 [3] httr_1.4.1 tools_4.0.0 [5] R6_2.4.1 irlba_2.3.3 [7] vipor_0.4.5 DBI_1.1.0 [9] colorspace_1.4-1 withr_2.2.0 [11] gridExtra_2.3 tidyselect_1.1.0 [13] processx_3.4.2 bit_1.1-15.2 [15] curl_4.3 compiler_4.0.0 [17] graph_1.67.0 BiocNeighbors_1.7.0 [19] bookdown_0.19 scales_1.1.1 [21] callr_3.4.3 rappdirs_0.3.1 [23] stringr_1.4.0 digest_0.6.25 [25] rmarkdown_2.1 XVector_0.29.0 [27] pkgconfig_2.0.3 htmltools_0.4.0 [29] limma_3.45.0 dbplyr_1.4.3 [31] fastmap_1.0.1 rlang_0.4.6 [33] RSQLite_2.2.0 shiny_1.4.0.2 [35] DelayedMatrixStats_1.11.0 BiocParallel_1.23.0 [37] dplyr_0.8.5 RCurl_1.98-1.2 [39] magrittr_1.5 BiocSingular_1.5.0 [41] scuttle_0.99.6 GenomeInfoDbData_1.2.3 [43] Matrix_1.2-18 Rcpp_1.0.4.6 [45] ggbeeswarm_0.6.0 munsell_0.5.0 [47] viridis_0.5.1 lifecycle_0.2.0 [49] edgeR_3.31.0 stringi_1.4.6 [51] yaml_2.2.1 zlibbioc_1.35.0 [53] BiocFileCache_1.13.0 AnnotationHub_2.21.0 [55] grid_4.0.0 blob_1.2.1 [57] dqrng_0.2.1 promises_1.1.0 [59] ExperimentHub_1.15.0 crayon_1.3.4 [61] lattice_0.20-41 locfit_1.5-9.4 [63] CodeDepends_0.6.5 knitr_1.28 [65] ps_1.3.3 pillar_1.4.4 [67] igraph_1.2.5 codetools_0.2-16 [69] XML_3.99-0.3 glue_1.4.1 [71] BiocVersion_3.12.0 evaluate_0.14 [73] scran_1.17.0 BiocManager_1.30.10 [75] vctrs_0.3.0 httpuv_1.5.2 [77] gtable_0.3.0 purrr_0.3.4 [79] assertthat_0.2.1 xfun_0.13 [81] rsvd_1.0.3 mime_0.9 [83] xtable_1.8-4 later_1.0.0 [85] viridisLite_0.3.0 tibble_3.0.1 [87] AnnotationDbi_1.51.0 beeswarm_0.2.3 [89] memoise_1.1.0 statmod_1.4.34 [91] ellipsis_0.3.1 interactiveDisplayBase_1.27.0 Bibliography "],
["contributors.html", "Chapter 9 Contributors", " Chapter 9 Contributors Aaron Lun An ancient interdimensional horror who has recently awoken from his aeons-long slumber. His true name cannot be pronounced by the human tongue and his true form cannot be grasped by the human mind. It is said that, when the stars are right, he will herald the return of the Old Ones to plunge the world into darkness once more. In the meantime, he maintains about 20 Bioconductor packages for analyzing a range of genomics data modalities. "],
["bibliography.html", "Chapter 10 Bibliography", " Chapter 10 Bibliography "]
]
